diff --git a/src/accounts/crafting_facility.rs b/src/accounts/crafting_facility.rs
index 0bdc77e..3c71ae2 100644
--- a/src/accounts/crafting_facility.rs
+++ b/src/accounts/crafting_facility.rs
@@ -1,7 +1,5 @@
 //! This code was AUTOGENERATED using the Codama library.
-use carbon_core::CarbonDeserialize;
-use carbon_core::borsh;
-use carbon_core::deserialize::CarbonDeserialize;
+use carbon_core::borsh::{self, BorshDeserialize};
 use solana_pubkey::Pubkey;
 
 use crate::types::LocationType;
@@ -9,7 +7,7 @@ use crate::types::LocationType;
 /// Represents a crafting facility account
 
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
-#[derive(Debug, Clone, borsh::BorshSerialize, CarbonDeserialize, PartialEq)]
+#[derive(Debug, Clone, PartialEq)]
 pub struct CraftingFacility {
     /// The data version of this account.
     pub version: u8,
@@ -28,22 +26,81 @@ pub struct CraftingFacility {
     pub efficiency: u32,
     /// number of recipe categories
     pub num_recipe_categories: u32,
+    /// RemainingData: UnorderedList<WrappedRecipeCategory>
+    pub recipe_categories: Vec<Pubkey>,
+}
+
+impl borsh::de::BorshDeserialize for CraftingFacility
+where
+    u8: borsh::BorshDeserialize,
+    Pubkey: borsh::BorshDeserialize,
+    LocationType: borsh::BorshDeserialize,
+    u32: borsh::BorshDeserialize,
+{
+    fn deserialize_reader<R: borsh::io::Read>(
+        reader: &mut R,
+    ) -> Result<Self, borsh::io::Error> {
+        Ok(Self {
+            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            domain: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            location: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            location_type: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            max_concurrent_processes: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            num_concurrent_processes: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            efficiency: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            num_recipe_categories: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            recipe_categories: Vec::new(), // Will be populated by CarbonDeserialize
+        })
+    }
+}
+
+impl carbon_core::deserialize::CarbonDeserialize for CraftingFacility {
+    const DISCRIMINATOR: &'static [u8] = &[58u8, 73u8, 35u8, 17u8, 92u8, 247u8, 49u8, 30u8];
+
+    fn deserialize(data: &[u8]) -> Option<Self> {
+        // CraftingFacility has RemainingData = UnorderedList<WrappedRecipeCategory>
+        // Contains a list of recipe category pubkeys (no length prefix in account)
+        // Byte layout: version(1) + domain(32) + location(32) + location_type(1) + max_concurrent_processes(4) + num_concurrent_processes(4) + efficiency(4) + num_recipe_categories(4) = 82 bytes
+        // All remaining bytes after fixed fields are Pubkeys (32 bytes each)
+
+        let mut rest = data;
+
+        let mut crafting_facility: CraftingFacility = match BorshDeserialize::deserialize(&mut rest) {
+            Ok(res) => res,
+            Err(_) => return None,
+        };
+
+        // Read num_recipe_categories pubkeys from remaining data
+        let num_categories = crafting_facility.num_recipe_categories as usize;
+        let mut recipe_categories = Vec::with_capacity(num_categories);
+
+        for _ in 0..num_categories {
+            let pubkey: Pubkey = match BorshDeserialize::deserialize(&mut rest) {
+                Ok(p) => p,
+                Err(_) => return None,
+            };
+            recipe_categories.push(pubkey);
+        }
+
+        crafting_facility.recipe_categories = recipe_categories;
+
+        Some(crafting_facility)
+    }
 }
 
 impl CraftingFacility {
     pub fn decode(data: &[u8]) -> Option<Self> {
+        use carbon_core::deserialize::CarbonDeserialize;
+
         if data.len() < 8 {
             return None;
         }
         let discriminator = &data[0..8];
-        if discriminator != &[58, 73, 35, 17, 92, 247, 49, 30] {
+        if discriminator != Self::DISCRIMINATOR {
             return None;
         }
 
-        let data_slice = data;
-
-        let data_slice = &data_slice[8..];
-
-        Self::deserialize(data_slice)
+        let data_slice = &data[8..];
+        <CraftingFacility as CarbonDeserialize>::deserialize(data_slice)
     }
 }
diff --git a/src/accounts/recipe.rs b/src/accounts/recipe.rs
index b71e6bc..eb919cd 100644
--- a/src/accounts/recipe.rs
+++ b/src/accounts/recipe.rs
@@ -1,14 +1,13 @@
 //! This code was AUTOGENERATED using the Codama library.
-use crate::types::{OptionalNonSystemPubkey, RecipeStatus};
-use carbon_core::CarbonDeserialize;
-use carbon_core::borsh;
-use carbon_core::deserialize::CarbonDeserialize;
+use carbon_core::borsh::{self, BorshDeserialize};
 use solana_pubkey::Pubkey;
 
+use crate::types::{OptionalNonSystemPubkey, RecipeInputsOutputs, RecipeStatus};
+
 /// The definition of a recipe.
 
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
-#[derive(Debug, Clone, borsh::BorshSerialize, CarbonDeserialize, PartialEq)]
+#[derive(Debug, Clone, PartialEq)]
 pub struct Recipe {
     /// The data version of this account.
     pub version: u8,
@@ -45,22 +44,93 @@ pub struct Recipe {
     pub outputs_count: u8,
     /// The number of all inputs and outputs in this recipe.
     pub total_count: u16,
+    /// RemainingData: UnorderedList<RecipeInputsOutputs>
+    pub recipe_items: Vec<RecipeInputsOutputs>,
+}
+
+impl borsh::de::BorshDeserialize for Recipe
+where
+    u8: borsh::BorshDeserialize,
+    Pubkey: borsh::BorshDeserialize,
+    i64: borsh::BorshDeserialize,
+    RecipeStatus: borsh::BorshDeserialize,
+    u64: borsh::BorshDeserialize,
+    OptionalNonSystemPubkey: borsh::BorshDeserialize,
+    u16: borsh::BorshDeserialize,
+{
+    fn deserialize_reader<R: borsh::io::Read>(
+        reader: &mut R,
+    ) -> Result<Self, borsh::io::Error> {
+        Ok(Self {
+            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            domain: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            category: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            creator: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            duration: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            min_duration: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            namespace: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            status: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            fee_amount: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            fee_recipient: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            usage_count: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            usage_limit: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            value: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            consumables_count: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            non_consumables_count: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            outputs_count: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            total_count: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            recipe_items: Vec::new(), // Will be populated by CarbonDeserialize
+        })
+    }
+}
+
+impl carbon_core::deserialize::CarbonDeserialize for Recipe {
+    const DISCRIMINATOR: &'static [u8] = &[10u8, 162u8, 156u8, 100u8, 56u8, 193u8, 205u8, 77u8];
+
+    fn deserialize(data: &[u8]) -> Option<Self> {
+        // Recipe has RemainingData = UnorderedList<RecipeInputsOutputs>
+        // Contains recipe inputs/outputs with amount and mint for each item
+        // Byte layout: version(1) + domain(32) + category(32) + creator(32) + duration(8) + min_duration(8) + namespace(32) + status(1) + fee_amount(8) + fee_recipient(33) + usage_count(8) + usage_limit(8) + value(8) + consumables_count(1) + non_consumables_count(1) + outputs_count(1) + total_count(2) = 216 bytes
+        // After fixed fields: total_count RecipeInputsOutputs structs (40 bytes each: 8 bytes for u64 amount + 32 bytes for Pubkey mint)
+
+        let mut rest = data;
+
+        let mut recipe: Recipe = match BorshDeserialize::deserialize(&mut rest) {
+            Ok(res) => res,
+            Err(_) => return None,
+        };
+
+        // Read total_count RecipeInputsOutputs from remaining data
+        let total_count = recipe.total_count as usize;
+        let mut recipe_items = Vec::with_capacity(total_count);
+
+        for _ in 0..total_count {
+            let item: RecipeInputsOutputs = match BorshDeserialize::deserialize(&mut rest) {
+                Ok(i) => i,
+                Err(_) => return None,
+            };
+            recipe_items.push(item);
+        }
+
+        recipe.recipe_items = recipe_items;
+
+        Some(recipe)
+    }
 }
 
 impl Recipe {
     pub fn decode(data: &[u8]) -> Option<Self> {
+        use carbon_core::deserialize::CarbonDeserialize;
+
         if data.len() < 8 {
             return None;
         }
         let discriminator = &data[0..8];
-        if discriminator != &[10, 162, 156, 100, 56, 193, 205, 77] {
+        if discriminator != Self::DISCRIMINATOR {
             return None;
         }
 
-        let data_slice = data;
-
-        let data_slice = &data_slice[8..];
-
-        Self::deserialize(data_slice)
+        let data_slice = &data[8..];
+        <Recipe as CarbonDeserialize>::deserialize(data_slice)
     }
 }
