diff --git a/src/accounts/point_category.rs b/src/accounts/point_category.rs
index 41e21fb..d035b0f 100644
--- a/src/accounts/point_category.rs
+++ b/src/accounts/point_category.rs
@@ -1,13 +1,13 @@
 //! This code was AUTOGENERATED using the Codama library.
-use carbon_core::CarbonDeserialize;
-use carbon_core::borsh;
-use carbon_core::deserialize::CarbonDeserialize;
+use carbon_core::borsh::{self, BorshDeserialize};
 use solana_pubkey::Pubkey;
 
+use crate::types::PointsLevel;
+
 /// PDA for each specific type of Points
 
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
-#[derive(Debug, Clone, borsh::BorshSerialize, CarbonDeserialize, PartialEq)]
+#[derive(Debug, Clone, PartialEq)]
 pub struct PointCategory {
     /// The data version of this account.
     pub version: u8,
@@ -30,22 +30,88 @@ pub struct PointCategory {
     /// the number of points required to upgrade a level after a user gets to the last level as set
     /// in the levels array.  If 0, this is turned off.
     pub post_levels_upgrade_threshold: u64,
+    /// RemainingData: UnorderedList<PointsLevel, u32>
+    pub levels: Vec<PointsLevel>,
+}
+
+impl borsh::de::BorshDeserialize for PointCategory
+where
+    u8: borsh::BorshDeserialize,
+    Pubkey: borsh::BorshDeserialize,
+    u64: borsh::BorshDeserialize,
+{
+    fn deserialize_reader<R: borsh::io::Read>(
+        reader: &mut R,
+    ) -> Result<Self, borsh::io::Error> {
+        Ok(Self {
+            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            profile: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            token_required: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            token_mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            token_qty: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            transfer_tokens_to_vault: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            token_vault: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            point_limit: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            is_spendable: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            post_levels_upgrade_threshold: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            levels: Vec::new(), // Will be populated by CarbonDeserialize
+        })
+    }
+}
+
+impl carbon_core::deserialize::CarbonDeserialize for PointCategory {
+    const DISCRIMINATOR: &'static [u8] = &[248u8, 7u8, 84u8, 202u8, 50u8, 104u8, 143u8, 34u8];
+
+    fn deserialize(data: &[u8]) -> Option<Self> {
+        // PointCategory has RemainingData = UnorderedList<PointsLevel, u32>
+        // Contains a u32 length prefix followed by that many PointsLevel structs
+        // Byte layout: version(1) + profile(32) + token_required(1) + token_mint(32) + token_qty(8) +
+        //              transfer_tokens_to_vault(1) + token_vault(32) + point_limit(8) + is_spendable(1) +
+        //              post_levels_upgrade_threshold(8) = 124 bytes
+        // After fixed fields: u32 length + (length * PointsLevel)
+
+        let mut rest = data;
+
+        let mut point_category: PointCategory = match BorshDeserialize::deserialize(&mut rest) {
+            Ok(res) => res,
+            Err(_) => return None,
+        };
+
+        // Read u32 length prefix
+        let levels_count: u32 = match BorshDeserialize::deserialize(&mut rest) {
+            Ok(count) => count,
+            Err(_) => return None,
+        };
+
+        // Read each PointsLevel
+        let mut levels = Vec::with_capacity(levels_count as usize);
+        for _ in 0..levels_count {
+            let level: PointsLevel = match BorshDeserialize::deserialize(&mut rest) {
+                Ok(l) => l,
+                Err(_) => return None,
+            };
+            levels.push(level);
+        }
+
+        point_category.levels = levels;
+
+        Some(point_category)
+    }
 }
 
 impl PointCategory {
     pub fn decode(data: &[u8]) -> Option<Self> {
+        use carbon_core::deserialize::CarbonDeserialize;
+
         if data.len() < 8 {
             return None;
         }
         let discriminator = &data[0..8];
-        if discriminator != &[248, 7, 84, 202, 50, 104, 143, 34] {
+        if discriminator != Self::DISCRIMINATOR {
             return None;
         }
 
-        let data_slice = data;
-
-        let data_slice = &data_slice[8..];
-
-        Self::deserialize(data_slice)
+        let data_slice = &data[8..];
+        <PointCategory as CarbonDeserialize>::deserialize(data_slice)
     }
 }
