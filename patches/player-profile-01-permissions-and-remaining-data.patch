diff --git a/Cargo.toml b/Cargo.toml
index 5152e1e..f6e2862 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -21,6 +21,7 @@ default = []
 serde = ["dep:serde", "dep:serde-big-array"]
 
 [dependencies]
+bitflags = "2.6"
 carbon-core = { version = "0.12.0", features = ["macros"], default-features = false }
 borsh = { version = "1.5.1", features = ["derive"] }
 solana-pubkey = { version = "3.0.0", features = ["borsh", "serde"] }
diff --git a/src/accounts/player_name.rs b/src/accounts/player_name.rs
index fdd3b5d..63200db 100644
--- a/src/accounts/player_name.rs
+++ b/src/accounts/player_name.rs
@@ -1,13 +1,11 @@
 //! This code was AUTOGENERATED using the Codama library.
-use carbon_core::CarbonDeserialize;
-use carbon_core::borsh;
-use carbon_core::deserialize::CarbonDeserialize;
+use carbon_core::borsh::{self, BorshDeserialize};
 use solana_pubkey::Pubkey;
 
 /// Stores a player's name on-chain.
 
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
-#[derive(Debug, Clone, borsh::BorshSerialize, CarbonDeserialize, PartialEq)]
+#[derive(Debug, Clone, PartialEq)]
 pub struct PlayerName {
     /// The data version of this account.
     pub version: u8,
@@ -15,22 +13,62 @@ pub struct PlayerName {
     pub profile: Pubkey,
     /// The bump for this account.
     pub bump: u8,
+    /// RemainingData: Bytes (the player's name)
+    pub name: Vec<u8>,
+}
+
+impl borsh::de::BorshDeserialize for PlayerName
+where
+    u8: borsh::BorshDeserialize,
+    Pubkey: borsh::BorshDeserialize,
+{
+    fn deserialize_reader<R: borsh::io::Read>(
+        reader: &mut R,
+    ) -> Result<Self, borsh::io::Error> {
+        Ok(Self {
+            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            profile: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            bump: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            name: Vec::new(), // Will be populated by CarbonDeserialize
+        })
+    }
+}
+
+impl carbon_core::deserialize::CarbonDeserialize for PlayerName {
+    const DISCRIMINATOR: &'static [u8] = &[102u8, 9u8, 241u8, 98u8, 96u8, 196u8, 212u8, 161u8];
+
+    fn deserialize(data: &[u8]) -> Option<Self> {
+        // PlayerName has RemainingData = Bytes (no length prefix, just raw bytes)
+        // All remaining bytes after the fixed fields are the player's name
+        // Fixed fields: version(1) + profile(32) + bump(1) = 34 bytes
+
+        let mut rest = data;
+
+        let mut player_name: PlayerName = match BorshDeserialize::deserialize(&mut rest) {
+            Ok(res) => res,
+            Err(_) => return None,
+        };
+
+        // All remaining bytes are the name
+        player_name.name = rest.to_vec();
+
+        Some(player_name)
+    }
 }
 
 impl PlayerName {
     pub fn decode(data: &[u8]) -> Option<Self> {
+        use carbon_core::deserialize::CarbonDeserialize;
+
         if data.len() < 8 {
             return None;
         }
         let discriminator = &data[0..8];
-        if discriminator != &[102, 9, 241, 98, 96, 196, 212, 161] {
+        if discriminator != Self::DISCRIMINATOR {
             return None;
         }
 
-        let data_slice = data;
-
-        let data_slice = &data_slice[8..];
-
-        Self::deserialize(data_slice)
+        let data_slice = &data[8..];
+        <PlayerName as CarbonDeserialize>::deserialize(data_slice)
     }
 }
diff --git a/src/accounts/profile.rs b/src/accounts/profile.rs
index 4bab46d..efcecf5 100644
--- a/src/accounts/profile.rs
+++ b/src/accounts/profile.rs
@@ -1,12 +1,12 @@
 //! This code was AUTOGENERATED using the Codama library.
-use carbon_core::CarbonDeserialize;
-use carbon_core::borsh;
-use carbon_core::deserialize::CarbonDeserialize;
+use carbon_core::borsh::{self, BorshDeserialize};
+
+use crate::types::ProfileKey;
 
 /// A player profile.
 
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
-#[derive(Debug, Clone, borsh::BorshSerialize, CarbonDeserialize, PartialEq)]
+#[derive(Debug, Clone, PartialEq)]
 pub struct Profile {
     /// The data version of this account.
     pub version: u8,
@@ -18,22 +18,82 @@ pub struct Profile {
     pub next_seq_id: u64,
     /// When the profile was created.
     pub created_at: i64,
+    /// RemainingData: UnorderedList<ProfileKey, u16>
+    pub profile_keys: Vec<ProfileKey>,
+}
+
+impl borsh::de::BorshDeserialize for Profile
+where
+    u8: borsh::BorshDeserialize,
+    u16: borsh::BorshDeserialize,
+    u64: borsh::BorshDeserialize,
+    i64: borsh::BorshDeserialize,
+{
+    fn deserialize_reader<R: borsh::io::Read>(
+        reader: &mut R,
+    ) -> Result<Self, borsh::io::Error> {
+        Ok(Self {
+            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            auth_key_count: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            key_threshold: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            next_seq_id: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            created_at: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            profile_keys: Vec::new(), // Will be populated by CarbonDeserialize
+        })
+    }
+}
+
+impl carbon_core::deserialize::CarbonDeserialize for Profile {
+    const DISCRIMINATOR: &'static [u8] = &[184u8, 101u8, 165u8, 188u8, 95u8, 63u8, 127u8, 188u8];
+
+    fn deserialize(data: &[u8]) -> Option<Self> {
+        // Profile has RemainingData = UnorderedList<ProfileKey, u16>
+        // The u16 length prefix is stored after the fixed fields (20 bytes total)
+        // Byte layout: version(1) + auth_key_count(2) + key_threshold(1) + next_seq_id(8) + created_at(8) = 20 bytes
+
+        let mut rest = data;
+
+        let profile: Profile = match BorshDeserialize::deserialize(&mut rest) {
+            Ok(res) => res,
+            Err(_) => return None,
+        };
+
+        // Read u16 length prefix
+        let list_length: u16 = match BorshDeserialize::deserialize(&mut rest) {
+            Ok(count) => count,
+            Err(_) => return None,
+        };
+
+        // Read each ProfileKey
+        let mut profile_keys = Vec::with_capacity(list_length as usize);
+        for _ in 0..list_length {
+            let key: ProfileKey = match BorshDeserialize::deserialize(&mut rest) {
+                Ok(k) => k,
+                Err(_) => return None,
+            };
+            profile_keys.push(key);
+        }
+
+        let mut final_profile = profile;
+        final_profile.profile_keys = profile_keys;
+
+        Some(final_profile)
+    }
 }
 
 impl Profile {
     pub fn decode(data: &[u8]) -> Option<Self> {
+        use carbon_core::deserialize::CarbonDeserialize;
+
         if data.len() < 8 {
             return None;
         }
         let discriminator = &data[0..8];
-        if discriminator != &[184, 101, 165, 188, 95, 63, 127, 188] {
+        if discriminator != Self::DISCRIMINATOR {
             return None;
         }
 
-        let data_slice = data;
-
-        let data_slice = &data_slice[8..];
-
-        Self::deserialize(data_slice)
+        let data_slice = &data[8..];
+        <Profile as CarbonDeserialize>::deserialize(data_slice)
     }
 }
diff --git a/src/accounts/profile_role_membership.rs b/src/accounts/profile_role_membership.rs
index fa44880..a1823df 100644
--- a/src/accounts/profile_role_membership.rs
+++ b/src/accounts/profile_role_membership.rs
@@ -1,14 +1,14 @@
 //! This code was AUTOGENERATED using the Codama library.
-use carbon_core::CarbonDeserialize;
-use carbon_core::borsh;
-use carbon_core::deserialize::CarbonDeserialize;
+use carbon_core::borsh::{self, BorshDeserialize};
 use solana_pubkey::Pubkey;
 
+use crate::types::RoleMembership;
+
 /// A player's roles for a given profile
 /// Remaining data contains an unordered list of [`RoleMembership`](RoleMembership) structs
 
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
-#[derive(Debug, Clone, borsh::BorshSerialize, CarbonDeserialize, PartialEq)]
+#[derive(Debug, Clone, PartialEq)]
 pub struct ProfileRoleMembership {
     /// The data version of this account.
     pub version: u8,
@@ -18,22 +18,80 @@ pub struct ProfileRoleMembership {
     pub member: Pubkey,
     /// PDA bump
     pub bump: u8,
+    /// RemainingData: UnorderedList<RoleMembership, u32>
+    pub memberships: Vec<RoleMembership>,
+}
+
+impl borsh::de::BorshDeserialize for ProfileRoleMembership
+where
+    u8: borsh::BorshDeserialize,
+    Pubkey: borsh::BorshDeserialize,
+{
+    fn deserialize_reader<R: borsh::io::Read>(
+        reader: &mut R,
+    ) -> Result<Self, borsh::io::Error> {
+        Ok(Self {
+            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            profile: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            member: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            bump: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            memberships: Vec::new(), // Will be populated by CarbonDeserialize
+        })
+    }
+}
+
+impl carbon_core::deserialize::CarbonDeserialize for ProfileRoleMembership {
+    const DISCRIMINATOR: &'static [u8] = &[45u8, 2u8, 86u8, 111u8, 110u8, 121u8, 5u8, 1u8];
+
+    fn deserialize(data: &[u8]) -> Option<Self> {
+        // ProfileRoleMembership has RemainingData = UnorderedList<RoleMembership, u32>
+        // The u32 length prefix is stored after the fixed fields (66 bytes total)
+        // Byte layout: version(1) + profile(32) + member(32) + bump(1) = 66 bytes
+
+        let mut rest = data;
+
+        let profile_role_membership: ProfileRoleMembership =
+            match BorshDeserialize::deserialize(&mut rest) {
+                Ok(res) => res,
+                Err(_) => return None,
+            };
+
+        // Read u32 length prefix
+        let list_length: u32 = match BorshDeserialize::deserialize(&mut rest) {
+            Ok(count) => count,
+            Err(_) => return None,
+        };
+
+        // Read each RoleMembership
+        let mut memberships = Vec::with_capacity(list_length as usize);
+        for _ in 0..list_length {
+            let membership: RoleMembership = match BorshDeserialize::deserialize(&mut rest) {
+                Ok(m) => m,
+                Err(_) => return None,
+            };
+            memberships.push(membership);
+        }
+
+        let mut final_profile_role_membership = profile_role_membership;
+        final_profile_role_membership.memberships = memberships;
+
+        Some(final_profile_role_membership)
+    }
 }
 
 impl ProfileRoleMembership {
     pub fn decode(data: &[u8]) -> Option<Self> {
+        use carbon_core::deserialize::CarbonDeserialize;
+
         if data.len() < 8 {
             return None;
         }
         let discriminator = &data[0..8];
-        if discriminator != &[45, 2, 86, 111, 110, 121, 5, 1] {
+        if discriminator != Self::DISCRIMINATOR {
             return None;
         }
 
-        let data_slice = data;
-
-        let data_slice = &data_slice[8..];
-
-        Self::deserialize(data_slice)
+        let data_slice = &data[8..];
+        <ProfileRoleMembership as CarbonDeserialize>::deserialize(data_slice)
     }
 }
diff --git a/src/accounts/role.rs b/src/accounts/role.rs
index a38f680..a1c0f6e 100644
--- a/src/accounts/role.rs
+++ b/src/accounts/role.rs
@@ -1,14 +1,14 @@
 //! This code was AUTOGENERATED using the Codama library.
-use carbon_core::CarbonDeserialize;
-use carbon_core::borsh;
-use carbon_core::deserialize::CarbonDeserialize;
+use carbon_core::borsh::{self, BorshDeserialize};
 use solana_pubkey::Pubkey;
 
+use crate::types::RoleMembership;
+
 /// A Role associated with a Profile. A Role contains an unordered list of Role Members in its
 /// remaining data which lists all of the members who carry this role.
 
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
-#[derive(Debug, Clone, borsh::BorshSerialize, CarbonDeserialize, PartialEq)]
+#[derive(Debug, Clone, PartialEq)]
 pub struct Role {
     /// The data version of this account.
     pub version: u8,
@@ -24,22 +24,82 @@ pub struct Role {
     /// TODO: Add instruction to use `player-name` as the label
     /// PDA bump
     pub bump: u8,
+    /// RemainingData: UnorderedList<RoleMembership, u32>
+    pub members: Vec<RoleMembership>,
+}
+
+impl borsh::de::BorshDeserialize for Role
+where
+    u8: borsh::BorshDeserialize,
+    Pubkey: borsh::BorshDeserialize,
+    u64: borsh::BorshDeserialize,
+{
+    fn deserialize_reader<R: borsh::io::Read>(
+        reader: &mut R,
+    ) -> Result<Self, borsh::io::Error> {
+        Ok(Self {
+            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            profile: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            authorizer: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            role_seq_id: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            accepting_new_members: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            bump: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            members: Vec::new(), // Will be populated by CarbonDeserialize
+        })
+    }
+}
+
+impl carbon_core::deserialize::CarbonDeserialize for Role {
+    const DISCRIMINATOR: &'static [u8] = &[46u8, 219u8, 197u8, 24u8, 233u8, 249u8, 253u8, 154u8];
+
+    fn deserialize(data: &[u8]) -> Option<Self> {
+        // Role has RemainingData = UnorderedList<RoleMembership, u32>
+        // The u32 length prefix is stored after the fixed fields (75 bytes total)
+        // Byte layout: version(1) + profile(32) + authorizer(32) + role_seq_id(8) + accepting_new_members(1) + bump(1) = 75 bytes
+
+        let mut rest = data;
+
+        let role: Role = match BorshDeserialize::deserialize(&mut rest) {
+            Ok(res) => res,
+            Err(_) => return None,
+        };
+
+        // Read u32 length prefix
+        let list_length: u32 = match BorshDeserialize::deserialize(&mut rest) {
+            Ok(count) => count,
+            Err(_) => return None,
+        };
+
+        // Read each RoleMembership
+        let mut members = Vec::with_capacity(list_length as usize);
+        for _ in 0..list_length {
+            let member: RoleMembership = match BorshDeserialize::deserialize(&mut rest) {
+                Ok(m) => m,
+                Err(_) => return None,
+            };
+            members.push(member);
+        }
+
+        let mut final_role = role;
+        final_role.members = members;
+
+        Some(final_role)
+    }
 }
 
 impl Role {
     pub fn decode(data: &[u8]) -> Option<Self> {
+        use carbon_core::deserialize::CarbonDeserialize;
+
         if data.len() < 8 {
             return None;
         }
         let discriminator = &data[0..8];
-        if discriminator != &[46, 219, 197, 24, 233, 249, 253, 154] {
+        if discriminator != Self::DISCRIMINATOR {
             return None;
         }
 
-        let data_slice = data;
-
-        let data_slice = &data_slice[8..];
-
-        Self::deserialize(data_slice)
+        let data_slice = &data[8..];
+        <Role as CarbonDeserialize>::deserialize(data_slice)
     }
 }
diff --git a/src/types/add_key_input.rs b/src/types/add_key_input.rs
index 29f0f07..d99696f 100644
--- a/src/types/add_key_input.rs
+++ b/src/types/add_key_input.rs
@@ -1,6 +1,9 @@
 //! This code was AUTOGENERATED using the Codama library.
 use carbon_core::borsh;
 use solana_pubkey::Pubkey;
+
+use super::ProfilePermissions;
+
 /// Struct for adding a key
 
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
@@ -14,3 +17,25 @@ pub struct AddKeyInput {
     pub permissions: [u8; 8],
 }
 
+impl AddKeyInput {
+    /// Convert the raw permission bytes to a u64 value.
+    pub fn permissions_as_u64(&self) -> u64 {
+        u64::from_le_bytes(self.permissions)
+    }
+
+    /// Get the permissions as a ProfilePermissions bitflags type.
+    pub fn permissions_flags(&self) -> ProfilePermissions {
+        ProfilePermissions::from_le_bytes(self.permissions)
+    }
+
+    /// Check if this input has a specific permission flag set.
+    pub fn has_permission(&self, flag: ProfilePermissions) -> bool {
+        self.permissions_flags().contains(flag)
+    }
+
+    /// Check if this input grants auth permission.
+    pub fn is_auth(&self) -> bool {
+        self.has_permission(ProfilePermissions::AUTH)
+    }
+}
+
diff --git a/src/types/mod.rs b/src/types/mod.rs
index 70d1f4f..d53f822 100644
--- a/src/types/mod.rs
+++ b/src/types/mod.rs
@@ -3,10 +3,12 @@
 pub mod add_key_input;
 pub mod member_status;
 pub mod profile_key;
+pub mod profile_permissions;
 pub mod role_membership;
 
 pub use self::add_key_input::*;
 pub use self::member_status::*;
 pub use self::profile_key::*;
+pub use self::profile_permissions::*;
 pub use self::role_membership::*;
 
diff --git a/src/types/profile_key.rs b/src/types/profile_key.rs
index edea646..627cead 100644
--- a/src/types/profile_key.rs
+++ b/src/types/profile_key.rs
@@ -1,6 +1,9 @@
 //! This code was AUTOGENERATED using the Codama library.
 use carbon_core::borsh;
 use solana_pubkey::Pubkey;
+
+use super::ProfilePermissions;
+
 /// A key on a profile.
 
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
@@ -17,3 +20,31 @@ pub struct ProfileKey {
     pub permissions: [u8; 8],
 }
 
+impl ProfileKey {
+    /// Convert the raw permission bytes to a u64 value.
+    pub fn permissions_as_u64(&self) -> u64 {
+        u64::from_le_bytes(self.permissions)
+    }
+
+    /// Get the permissions as a ProfilePermissions bitflags type.
+    pub fn permissions_flags(&self) -> ProfilePermissions {
+        ProfilePermissions::from_le_bytes(self.permissions)
+    }
+
+    /// Check if this key has a specific permission flag set.
+    pub fn has_permission(&self, flag: ProfilePermissions) -> bool {
+        self.permissions_flags().contains(flag)
+    }
+
+    /// Check if this key is an auth key (has AUTH permission).
+    pub fn is_auth(&self) -> bool {
+        self.has_permission(ProfilePermissions::AUTH)
+    }
+
+    /// Check if this key has expired based on the given current time.
+    /// Keys with negative expire_time never expire.
+    pub fn is_expired(&self, current_time: i64) -> bool {
+        self.expire_time >= 0 && self.expire_time < current_time
+    }
+}
+
diff --git a/src/types/profile_permissions.rs b/src/types/profile_permissions.rs
new file mode 100644
index 0000000..9832450
--- /dev/null
+++ b/src/types/profile_permissions.rs
@@ -0,0 +1,60 @@
+use bitflags::bitflags;
+
+bitflags! {
+    /// Permissions for the player profile program.
+    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
+    pub struct ProfilePermissions: u64 {
+        /// Key is an auth key and can update the profile.
+        /// Key can also edit any permissions on it's own other than AUTH.
+        /// To edit AUTH permissions must meet the threshold.
+        /// Key must not expire.
+        const AUTH = 1 << 0;
+        /// Key can add non-auth keys.
+        /// May only add permissions that the key already has.
+        const ADD_KEYS = 1 << 1;
+        /// Key can remove non-auth keys.
+        const REMOVE_KEYS = 1 << 2;
+        /// Key can change the profile's player name.
+        const CHANGE_NAME = 1 << 3;
+        /// Key can create a new role on the profile.
+        const CREATE_ROLE = 1 << 4;
+        /// Key can remove a role from the profile.
+        const REMOVE_ROLE = 1 << 5;
+        /// Key can set a role's authorizer.
+        const SET_AUTHORIZER = 1 << 6;
+        /// Key can add profile to a role.
+        const JOIN_ROLE = 1 << 7;
+        /// Key can remove profile from a role.
+        const LEAVE_ROLE = 1 << 8;
+        /// Key can toggle accepting new members.
+        const TOGGLE_ACCEPTING_NEW_MEMBERS = 1 << 9;
+        /// Key can add a member to a role.
+        const ADD_MEMBER = 1 << 10;
+        /// Key can remove a member from a role.
+        const REMOVE_MEMBER = 1 << 11;
+        /// Key can withdraw from the SOL Vault. This permission is intended to work for any scope.
+        const DRAIN_SOL_VAULT = 1 << 63;
+    }
+}
+
+impl ProfilePermissions {
+    /// Create ProfilePermissions from a u64 value, truncating any unknown bits.
+    pub fn from_u64(bits: u64) -> Self {
+        Self::from_bits_truncate(bits)
+    }
+
+    /// Convert ProfilePermissions to a u64 value.
+    pub fn to_u64(self) -> u64 {
+        self.bits()
+    }
+
+    /// Create ProfilePermissions from little-endian bytes.
+    pub fn from_le_bytes(bytes: [u8; 8]) -> Self {
+        Self::from_u64(u64::from_le_bytes(bytes))
+    }
+
+    /// Convert ProfilePermissions to little-endian bytes.
+    pub fn to_le_bytes(self) -> [u8; 8] {
+        self.to_u64().to_le_bytes()
+    }
+}
