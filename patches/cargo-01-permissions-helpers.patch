diff --git a/Cargo.toml b/Cargo.toml
index 07c9666..7f3d812 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -21,6 +21,7 @@ default = []
 serde = ["dep:serde", "dep:serde-big-array"]
 
 [dependencies]
+bitflags = "2.6"
 carbon-core = { version = "0.12.0", features = ["macros"], default-features = false }
 borsh = { version = "1.5.1", features = ["derive"] }
 solana-pubkey = { version = "3.0.0", features = ["borsh", "serde"] }
diff --git a/src/accounts/cargo_pod.rs b/src/accounts/cargo_pod.rs
index 9154b25..3295262 100644
--- a/src/accounts/cargo_pod.rs
+++ b/src/accounts/cargo_pod.rs
@@ -1,13 +1,11 @@
 //! This code was AUTOGENERATED using the Codama library.
-use carbon_core::CarbonDeserialize;
-use carbon_core::borsh;
-use carbon_core::deserialize::CarbonDeserialize;
+use carbon_core::borsh::{self, BorshDeserialize};
 use solana_pubkey::Pubkey;
 
 /// A pod that can store any number of resources and tracks stats given a definition.
 
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
-#[derive(Debug, Clone, borsh::BorshSerialize, CarbonDeserialize, PartialEq)]
+#[derive(Debug, Clone, PartialEq)]
 pub struct CargoPod {
     /// The data version of this account.
     pub version: u8,
@@ -25,22 +23,80 @@ pub struct CargoPod {
     pub seq_id: u16,
     /// The number of unupdated token accounts in this pod. If this is greater than zero means the pod is frozen and only can withdraw cargo but not deposit.
     pub unupdated_token_accounts: u8,
+    /// RemainingData: List<PackedValue<u64>>
+    pub cargo_contents: Vec<u64>,
+}
+
+impl borsh::de::BorshDeserialize for CargoPod
+where
+    u8: borsh::BorshDeserialize,
+    Pubkey: borsh::BorshDeserialize,
+    u16: borsh::BorshDeserialize,
+{
+    fn deserialize_reader<R: borsh::io::Read>(
+        reader: &mut R,
+    ) -> Result<Self, borsh::io::Error> {
+        Ok(Self {
+            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            stats_definition: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            authority: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            open_token_accounts: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            pod_seeds: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            pod_bump: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            seq_id: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            unupdated_token_accounts: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            cargo_contents: Vec::new(), // Will be populated by CarbonDeserialize
+        })
+    }
+}
+
+impl carbon_core::deserialize::CarbonDeserialize for CargoPod {
+    const DISCRIMINATOR: &'static [u8] = &[165u8, 33u8, 118u8, 235u8, 252u8, 188u8, 244u8, 93u8];
+
+    fn deserialize(data: &[u8]) -> Option<Self> {
+        // CargoPod has RemainingData = List<PackedValue<u64>>
+        // Contains the contents of the cargo pod as a list of u64 (no length prefix in account)
+        // Byte layout: version(1) + stats_definition(32) + authority(32) + open_token_accounts(1) + pod_seeds(32) + pod_bump(1) + seq_id(2) + unupdated_token_accounts(1) = 102 bytes
+        // All remaining bytes after fixed fields are u64 cargo values
+
+        let mut rest = data;
+
+        let mut cargo_pod: CargoPod = match BorshDeserialize::deserialize(&mut rest) {
+            Ok(res) => res,
+            Err(_) => return None,
+        };
+
+        // Read all remaining bytes as u64 values (each u64 is 8 bytes)
+        let num_u64_values = rest.len() / 8;
+        let mut cargo_contents = Vec::with_capacity(num_u64_values);
+
+        for _ in 0..num_u64_values {
+            let value: u64 = match BorshDeserialize::deserialize(&mut rest) {
+                Ok(v) => v,
+                Err(_) => return None,
+            };
+            cargo_contents.push(value);
+        }
+
+        cargo_pod.cargo_contents = cargo_contents;
+
+        Some(cargo_pod)
+    }
 }
 
 impl CargoPod {
     pub fn decode(data: &[u8]) -> Option<Self> {
+        use carbon_core::deserialize::CarbonDeserialize;
+
         if data.len() < 8 {
             return None;
         }
         let discriminator = &data[0..8];
-        if discriminator != &[165, 33, 118, 235, 252, 188, 244, 93] {
+        if discriminator != Self::DISCRIMINATOR {
             return None;
         }
 
-        let data_slice = data;
-
-        let data_slice = &data_slice[8..];
-
-        Self::deserialize(data_slice)
+        let data_slice = &data[8..];
+        <CargoPod as CarbonDeserialize>::deserialize(data_slice)
     }
 }
diff --git a/src/types/cargo_permissions.rs b/src/types/cargo_permissions.rs
new file mode 100644
index 0000000..0b754e2
--- /dev/null
+++ b/src/types/cargo_permissions.rs
@@ -0,0 +1,36 @@
+use bitflags::bitflags;
+
+bitflags! {
+    /// Permissions for the cargo program.
+    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
+    pub struct CargoPermissions: u64 {
+        /// Key can init and update cargo definitions.
+        const MANAGE_DEFINITION = 1 << 0;
+        /// Key can create cargo types.
+        const CREATE_CARGO_TYPE = 1 << 1;
+        /// Key can update cargo types.
+        const MANAGE_CARGO_TYPE = 1 << 2;
+    }
+}
+
+impl CargoPermissions {
+    /// Create CargoPermissions from a u64 value, truncating any unknown bits.
+    pub fn from_u64(bits: u64) -> Self {
+        Self::from_bits_truncate(bits)
+    }
+
+    /// Convert CargoPermissions to a u64 value.
+    pub fn to_u64(self) -> u64 {
+        self.bits()
+    }
+
+    /// Create CargoPermissions from little-endian bytes.
+    pub fn from_le_bytes(bytes: [u8; 8]) -> Self {
+        Self::from_u64(u64::from_le_bytes(bytes))
+    }
+
+    /// Convert CargoPermissions to little-endian bytes.
+    pub fn to_le_bytes(self) -> [u8; 8] {
+        self.to_u64().to_le_bytes()
+    }
+}
diff --git a/src/types/mod.rs b/src/types/mod.rs
index 7c9d7e4..c9e0e34 100644
--- a/src/types/mod.rs
+++ b/src/types/mod.rs
@@ -1,5 +1,8 @@
 //! This code was AUTOGENERATED using the Codama library.
 
+pub mod cargo_permissions;
+pub use cargo_permissions::*;
+
 pub mod init_cargo_type_from_old_cargo_type_input;
 pub mod init_cargo_type_input;
 pub mod init_definition_input;
