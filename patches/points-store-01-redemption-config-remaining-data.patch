diff --git a/src/accounts/redemption_config.rs b/src/accounts/redemption_config.rs
index 0ff38cf..846f69b 100644
--- a/src/accounts/redemption_config.rs
+++ b/src/accounts/redemption_config.rs
@@ -1,13 +1,13 @@
 //! This code was AUTOGENERATED using the Codama library.
-use carbon_core::CarbonDeserialize;
-use carbon_core::borsh;
-use carbon_core::deserialize::CarbonDeserialize;
+use carbon_core::borsh::{self, BorshDeserialize};
 use solana_pubkey::Pubkey;
 
+use crate::types::RedemptionEpoch;
+
 /// Configuration to allow use of points to redeem tokens.
 
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
-#[derive(Debug, Clone, borsh::BorshSerialize, CarbonDeserialize, PartialEq)]
+#[derive(Debug, Clone, PartialEq)]
 pub struct RedemptionConfig {
     /// The version of data in this struct.
     pub version: u8,
@@ -23,22 +23,80 @@ pub struct RedemptionConfig {
     pub signer_bump: u8,
     /// Allow only the current epoch to be redeemed
     pub allow_only_current_epoch: u8,
+    /// RemainingData: UnorderedList<RedemptionEpoch, u32>
+    pub redemption_epochs: Vec<RedemptionEpoch>,
+}
+
+impl borsh::de::BorshDeserialize for RedemptionConfig
+where
+    u8: borsh::BorshDeserialize,
+    Pubkey: borsh::BorshDeserialize,
+{
+    fn deserialize_reader<R: borsh::io::Read>(
+        reader: &mut R,
+    ) -> Result<Self, borsh::io::Error> {
+        Ok(Self {
+            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            point_category: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            profile: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            faction: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            bank: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            signer_bump: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            allow_only_current_epoch: borsh::BorshDeserialize::deserialize_reader(reader)?,
+            redemption_epochs: Vec::new(), // Will be populated by CarbonDeserialize
+        })
+    }
+}
+
+impl carbon_core::deserialize::CarbonDeserialize for RedemptionConfig {
+    const DISCRIMINATOR: &'static [u8] = &[173u8, 1u8, 86u8, 47u8, 27u8, 204u8, 146u8, 185u8];
+
+    fn deserialize(data: &[u8]) -> Option<Self> {
+        // RedemptionConfig has RemainingData = UnorderedList<RedemptionEpoch, u32>
+        // Contains a u32 length prefix followed by that many RedemptionEpoch structs
+
+        let mut rest = data;
+
+        let mut redemption_config: RedemptionConfig = match BorshDeserialize::deserialize(&mut rest) {
+            Ok(res) => res,
+            Err(_) => return None,
+        };
+
+        // Read u32 length prefix
+        let epochs_count: u32 = match BorshDeserialize::deserialize(&mut rest) {
+            Ok(count) => count,
+            Err(_) => return None,
+        };
+
+        // Read each RedemptionEpoch
+        let mut redemption_epochs = Vec::with_capacity(epochs_count as usize);
+        for _ in 0..epochs_count {
+            let epoch: RedemptionEpoch = match BorshDeserialize::deserialize(&mut rest) {
+                Ok(e) => e,
+                Err(_) => return None,
+            };
+            redemption_epochs.push(epoch);
+        }
+
+        redemption_config.redemption_epochs = redemption_epochs;
+
+        Some(redemption_config)
+    }
 }
 
 impl RedemptionConfig {
     pub fn decode(data: &[u8]) -> Option<Self> {
+        use carbon_core::deserialize::CarbonDeserialize;
+
         if data.len() < 8 {
             return None;
         }
         let discriminator = &data[0..8];
-        if discriminator != &[173, 1, 86, 47, 27, 204, 146, 185] {
+        if discriminator != Self::DISCRIMINATOR {
             return None;
         }
 
-        let data_slice = data;
-
-        let data_slice = &data_slice[8..];
-
-        Self::deserialize(data_slice)
+        let data_slice = &data[8..];
+        <RedemptionConfig as CarbonDeserialize>::deserialize(data_slice)
     }
 }
