diff --git a/src/accounts/fleet.rs b/src/accounts/fleet.rs
index 551f2c7..b0275c3 100644
--- a/src/accounts/fleet.rs
+++ b/src/accounts/fleet.rs
@@ -1,16 +1,21 @@
 //! This code was AUTOGENERATED using the Codama library.
+use crate::types::Idle;
+use crate::types::MineAsteroid;
+use crate::types::MoveSubwarp;
+use crate::types::MoveWarp;
 use crate::types::OptionalNonSystemPubkey;
+use crate::types::Respawn;
 use crate::types::ShipCounts;
 use crate::types::ShipStats;
-use carbon_core::CarbonDeserialize;
+use crate::types::StarbaseLoadingBay;
 use carbon_core::borsh;
-use carbon_core::deserialize::CarbonDeserialize;
+use carbon_core::borsh::BorshDeserialize;
 use solana_pubkey::Pubkey;
 
 /// A `SAGE` fleet.
 
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
-#[derive(Debug, Clone, borsh::BorshSerialize, CarbonDeserialize, PartialEq)]
+#[derive(Debug, Clone, PartialEq)]
 pub struct Fleet {
     /// The data version of this account.
     pub version: u8,
@@ -61,22 +66,71 @@ pub struct Fleet {
     pub update_id: u64,
     /// The fleet's bump.
     pub bump: u8,
+    /// The fleet's current state (remaining data)
+    pub fleet_state: FleetState,
 }
 
-impl Fleet {
-    pub fn decode(data: &[u8]) -> Option<Self> {
-        if data.len() < 8 {
+/// The state of the fleet
+#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
+#[derive(Debug, Clone, PartialEq, BorshDeserialize)]
+pub enum FleetState {
+    StarbaseLoadingBay(StarbaseLoadingBay),
+    Idle(Idle),
+    MineAsteroid(MineAsteroid),
+    MoveWarp(MoveWarp),
+    MoveSubwarp(MoveSubwarp),
+    Respawn(Respawn),
+}
+
+impl borsh::de::BorshDeserialize for Fleet {
+    fn deserialize_reader<R: borsh::io::Read>(reader: &mut R) -> Result<Self, borsh::io::Error> {
+        Ok(Self {
+            version: BorshDeserialize::deserialize_reader(reader)?,
+            game_id: BorshDeserialize::deserialize_reader(reader)?,
+            owner_profile: BorshDeserialize::deserialize_reader(reader)?,
+            fleet_ships: BorshDeserialize::deserialize_reader(reader)?,
+            sub_profile: BorshDeserialize::deserialize_reader(reader)?,
+            sub_profile_invalidator: BorshDeserialize::deserialize_reader(reader)?,
+            faction: BorshDeserialize::deserialize_reader(reader)?,
+            fleet_label: BorshDeserialize::deserialize_reader(reader)?,
+            ship_counts: BorshDeserialize::deserialize_reader(reader)?,
+            warp_cooldown_expires_at: BorshDeserialize::deserialize_reader(reader)?,
+            scan_cooldown_expires_at: BorshDeserialize::deserialize_reader(reader)?,
+            stats: BorshDeserialize::deserialize_reader(reader)?,
+            cargo_hold: BorshDeserialize::deserialize_reader(reader)?,
+            fuel_tank: BorshDeserialize::deserialize_reader(reader)?,
+            ammo_bank: BorshDeserialize::deserialize_reader(reader)?,
+            ap: BorshDeserialize::deserialize_reader(reader)?,
+            sp: BorshDeserialize::deserialize_reader(reader)?,
+            hp: BorshDeserialize::deserialize_reader(reader)?,
+            pending_hp: BorshDeserialize::deserialize_reader(reader)?,
+            ap_reload_expires_at: BorshDeserialize::deserialize_reader(reader)?,
+            shield_break_delay_expires_at: BorshDeserialize::deserialize_reader(reader)?,
+            last_combat_update: BorshDeserialize::deserialize_reader(reader)?,
+            update_id: BorshDeserialize::deserialize_reader(reader)?,
+            bump: BorshDeserialize::deserialize_reader(reader)?,
+            fleet_state: BorshDeserialize::deserialize_reader(reader)?,
+        })
+    }
+}
+
+impl carbon_core::deserialize::CarbonDeserialize for Fleet {
+    const DISCRIMINATOR: &'static [u8] = &[109u8, 207u8, 251u8, 48u8, 106u8, 2u8, 136u8, 163u8];
+
+    fn deserialize(data: &[u8]) -> Option<Self> {
+        if data.len() < Self::DISCRIMINATOR.len() {
             return None;
         }
-        let discriminator = &data[0..8];
-        if discriminator != &[109, 207, 251, 48, 106, 2, 136, 163] {
+        let (disc, mut rest) = data.split_at(Self::DISCRIMINATOR.len());
+        if disc != Self::DISCRIMINATOR {
             return None;
         }
+        BorshDeserialize::deserialize(&mut rest).ok()
+    }
+}
 
-        let data_slice = data;
-
-        let data_slice = &data_slice[8..];
-
-        Self::deserialize(data_slice)
+impl Fleet {
+    pub fn decode(data: &[u8]) -> Option<Self> {
+        <Self as carbon_core::deserialize::CarbonDeserialize>::deserialize(data)
     }
 }
diff --git a/src/accounts/starbase_player.rs b/src/accounts/starbase_player.rs
index 585bd45..c5d20a6 100644
--- a/src/accounts/starbase_player.rs
+++ b/src/accounts/starbase_player.rs
@@ -1,13 +1,13 @@
 //! This code was AUTOGENERATED using the Codama library.
-use carbon_core::CarbonDeserialize;
+use crate::types::WrappedShipEscrow;
 use carbon_core::borsh;
-use carbon_core::deserialize::CarbonDeserialize;
+use carbon_core::borsh::BorshDeserialize;
 use solana_pubkey::Pubkey;
 
 /// The `SAGE` player info within a `Starbase`
 
 #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
-#[derive(Debug, Clone, borsh::BorshSerialize, CarbonDeserialize, PartialEq)]
+#[derive(Debug, Clone, PartialEq)]
 pub struct StarbasePlayer {
     /// The data version of this account
     pub version: u8,
@@ -36,22 +36,66 @@ pub struct StarbasePlayer {
     /// Number of updated items in `RemainingData` list
     /// This will be `ship_escrow_count` when all ships in escrow are up-to-date
     pub updated_ship_escrow_count: u32,
+    /// Ship escrows (remaining data)
+    pub ship_escrows: Vec<WrappedShipEscrow>,
 }
 
-impl StarbasePlayer {
-    pub fn decode(data: &[u8]) -> Option<Self> {
-        if data.len() < 8 {
+impl borsh::de::BorshDeserialize for StarbasePlayer {
+    fn deserialize_reader<R: borsh::io::Read>(reader: &mut R) -> Result<Self, borsh::io::Error> {
+        let version = BorshDeserialize::deserialize_reader(reader)?;
+        let player_profile = BorshDeserialize::deserialize_reader(reader)?;
+        let game_id = BorshDeserialize::deserialize_reader(reader)?;
+        let starbase = BorshDeserialize::deserialize_reader(reader)?;
+        let sage_player_profile = BorshDeserialize::deserialize_reader(reader)?;
+        let bump = BorshDeserialize::deserialize_reader(reader)?;
+        let ship_escrow_count: u32 = BorshDeserialize::deserialize_reader(reader)?;
+        let old_total_crew = BorshDeserialize::deserialize_reader(reader)?;
+        let new_total_crew = BorshDeserialize::deserialize_reader(reader)?;
+        let busy_crew = BorshDeserialize::deserialize_reader(reader)?;
+        let update_id = BorshDeserialize::deserialize_reader(reader)?;
+        let updated_ship_escrow_count = BorshDeserialize::deserialize_reader(reader)?;
+
+        // Read ship_escrows based on updated_ship_escrow_count
+        let mut ship_escrows = Vec::with_capacity(updated_ship_escrow_count as usize);
+        for _ in 0..updated_ship_escrow_count {
+            ship_escrows.push(BorshDeserialize::deserialize_reader(reader)?);
+        }
+
+        Ok(Self {
+            version,
+            player_profile,
+            game_id,
+            starbase,
+            sage_player_profile,
+            bump,
+            ship_escrow_count,
+            old_total_crew,
+            new_total_crew,
+            busy_crew,
+            update_id,
+            updated_ship_escrow_count,
+            ship_escrows,
+        })
+    }
+}
+
+impl carbon_core::deserialize::CarbonDeserialize for StarbasePlayer {
+    const DISCRIMINATOR: &'static [u8] = &[192u8, 234u8, 144u8, 86u8, 72u8, 19u8, 5u8, 99u8];
+
+    fn deserialize(data: &[u8]) -> Option<Self> {
+        if data.len() < Self::DISCRIMINATOR.len() {
             return None;
         }
-        let discriminator = &data[0..8];
-        if discriminator != &[192, 234, 144, 86, 72, 19, 5, 99] {
+        let (disc, mut rest) = data.split_at(Self::DISCRIMINATOR.len());
+        if disc != Self::DISCRIMINATOR {
             return None;
         }
+        BorshDeserialize::deserialize(&mut rest).ok()
+    }
+}
 
-        let data_slice = data;
-
-        let data_slice = &data_slice[8..];
-
-        Self::deserialize(data_slice)
+impl StarbasePlayer {
+    pub fn decode(data: &[u8]) -> Option<Self> {
+        <Self as carbon_core::deserialize::CarbonDeserialize>::deserialize(data)
     }
 }
