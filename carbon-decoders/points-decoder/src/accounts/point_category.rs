//! This code was AUTOGENERATED using the Codama library.
use carbon_core::borsh::{self, BorshDeserialize};
use solana_pubkey::Pubkey;

use crate::types::PointsLevel;

/// PDA for each specific type of Points

#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, PartialEq)]
pub struct PointCategory {
    /// The data version of this account.
    pub version: u8,
    /// the managing profile
    pub profile: Pubkey,
    /// if this is true then token_mint should be a mint address
    pub token_required: u8,
    /// the token mint
    pub token_mint: Pubkey,
    /// the token qty
    pub token_qty: u64,
    /// if this is true then token_vault should be a token address
    pub transfer_tokens_to_vault: u8,
    /// the token vault
    pub token_vault: Pubkey,
    /// point limit
    pub point_limit: u64,
    /// is spendable?
    pub is_spendable: u8,
    /// the number of points required to upgrade a level after a user gets to the last level as set
    /// in the levels array.  If 0, this is turned off.
    pub post_levels_upgrade_threshold: u64,
    /// RemainingData: UnorderedList<PointsLevel, u32>
    pub levels: Vec<PointsLevel>,
}

impl borsh::de::BorshDeserialize for PointCategory
where
    u8: borsh::BorshDeserialize,
    Pubkey: borsh::BorshDeserialize,
    u64: borsh::BorshDeserialize,
{
    fn deserialize_reader<R: borsh::io::Read>(reader: &mut R) -> Result<Self, borsh::io::Error> {
        Ok(Self {
            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
            profile: borsh::BorshDeserialize::deserialize_reader(reader)?,
            token_required: borsh::BorshDeserialize::deserialize_reader(reader)?,
            token_mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
            token_qty: borsh::BorshDeserialize::deserialize_reader(reader)?,
            transfer_tokens_to_vault: borsh::BorshDeserialize::deserialize_reader(reader)?,
            token_vault: borsh::BorshDeserialize::deserialize_reader(reader)?,
            point_limit: borsh::BorshDeserialize::deserialize_reader(reader)?,
            is_spendable: borsh::BorshDeserialize::deserialize_reader(reader)?,
            post_levels_upgrade_threshold: borsh::BorshDeserialize::deserialize_reader(reader)?,
            levels: Vec::new(), // Will be populated by CarbonDeserialize
        })
    }
}

impl carbon_core::deserialize::CarbonDeserialize for PointCategory {
    const DISCRIMINATOR: &'static [u8] = &[248u8, 7u8, 84u8, 202u8, 50u8, 104u8, 143u8, 34u8];

    fn deserialize(data: &[u8]) -> Option<Self> {
        // PointCategory has RemainingData = UnorderedList<PointsLevel, u32>
        // Contains a u32 length prefix followed by that many PointsLevel structs
        // Byte layout: version(1) + profile(32) + token_required(1) + token_mint(32) + token_qty(8) +
        //              transfer_tokens_to_vault(1) + token_vault(32) + point_limit(8) + is_spendable(1) +
        //              post_levels_upgrade_threshold(8) = 124 bytes
        // After fixed fields: u32 length + (length * PointsLevel)

        let mut rest = data;

        let mut point_category: PointCategory = match BorshDeserialize::deserialize(&mut rest) {
            Ok(res) => res,
            Err(_) => return None,
        };

        // Read u32 length prefix
        let levels_count: u32 = match BorshDeserialize::deserialize(&mut rest) {
            Ok(count) => count,
            Err(_) => return None,
        };

        // Read each PointsLevel
        let mut levels = Vec::with_capacity(levels_count as usize);
        for _ in 0..levels_count {
            let level: PointsLevel = match BorshDeserialize::deserialize(&mut rest) {
                Ok(l) => l,
                Err(_) => return None,
            };
            levels.push(level);
        }

        point_category.levels = levels;

        Some(point_category)
    }
}

impl PointCategory {
    pub fn decode(data: &[u8]) -> Option<Self> {
        use carbon_core::deserialize::CarbonDeserialize;

        if data.len() < 8 {
            return None;
        }
        let discriminator = &data[0..8];
        if discriminator != Self::DISCRIMINATOR {
            return None;
        }

        let data_slice = &data[8..];
        <PointCategory as CarbonDeserialize>::deserialize(data_slice)
    }
}
