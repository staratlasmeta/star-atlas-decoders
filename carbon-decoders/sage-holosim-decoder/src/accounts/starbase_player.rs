//! This code was AUTOGENERATED using the Codama library.
use crate::types::WrappedShipEscrow;
use carbon_core::borsh;
use carbon_core::borsh::BorshDeserialize;
use solana_pubkey::Pubkey;

/// The `SAGE` player info within a `Starbase`

#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, PartialEq)]
pub struct StarbasePlayer {
    /// The data version of this account
    pub version: u8,
    /// The `Profile` key
    pub player_profile: Pubkey,
    /// The id of the `Game`
    pub game_id: Pubkey,
    /// The `Starbase` key
    pub starbase: Pubkey,
    /// The `SagePlayerProfile` key
    pub sage_player_profile: Pubkey,
    /// Bump of Account PDA
    pub bump: u8,
    /// List length of `RemainingData`
    pub ship_escrow_count: u32,
    /// The old total crew members from the player's fleets at the `Starbase`
    /// This is used BEFORE crew program features are turned ON
    pub old_total_crew: u32,
    /// The new total crew members from the player's fleets at the `Starbase`
    /// This is used AFTER crew program features are turned ON
    pub new_total_crew: u32,
    /// The number of crew members that is engaged/busy and not available
    pub busy_crew: u64,
    /// The `Game` update id
    pub update_id: u64,
    /// Number of updated items in `RemainingData` list
    /// This will be `ship_escrow_count` when all ships in escrow are up-to-date
    pub updated_ship_escrow_count: u32,
    /// Ship escrows (remaining data)
    pub ship_escrows: Vec<WrappedShipEscrow>,
}

impl borsh::de::BorshDeserialize for StarbasePlayer {
    fn deserialize_reader<R: borsh::io::Read>(reader: &mut R) -> Result<Self, borsh::io::Error> {
        let version = BorshDeserialize::deserialize_reader(reader)?;
        let player_profile = BorshDeserialize::deserialize_reader(reader)?;
        let game_id = BorshDeserialize::deserialize_reader(reader)?;
        let starbase = BorshDeserialize::deserialize_reader(reader)?;
        let sage_player_profile = BorshDeserialize::deserialize_reader(reader)?;
        let bump = BorshDeserialize::deserialize_reader(reader)?;
        let ship_escrow_count: u32 = BorshDeserialize::deserialize_reader(reader)?;
        let old_total_crew = BorshDeserialize::deserialize_reader(reader)?;
        let new_total_crew = BorshDeserialize::deserialize_reader(reader)?;
        let busy_crew = BorshDeserialize::deserialize_reader(reader)?;
        let update_id = BorshDeserialize::deserialize_reader(reader)?;
        let updated_ship_escrow_count = BorshDeserialize::deserialize_reader(reader)?;

        // Read ship_escrows based on updated_ship_escrow_count
        let mut ship_escrows = Vec::with_capacity(updated_ship_escrow_count as usize);
        for _ in 0..updated_ship_escrow_count {
            ship_escrows.push(BorshDeserialize::deserialize_reader(reader)?);
        }

        Ok(Self {
            version,
            player_profile,
            game_id,
            starbase,
            sage_player_profile,
            bump,
            ship_escrow_count,
            old_total_crew,
            new_total_crew,
            busy_crew,
            update_id,
            updated_ship_escrow_count,
            ship_escrows,
        })
    }
}

impl carbon_core::deserialize::CarbonDeserialize for StarbasePlayer {
    const DISCRIMINATOR: &'static [u8] = &[192u8, 234u8, 144u8, 86u8, 72u8, 19u8, 5u8, 99u8];

    fn deserialize(data: &[u8]) -> Option<Self> {
        if data.len() < Self::DISCRIMINATOR.len() {
            return None;
        }
        let (disc, mut rest) = data.split_at(Self::DISCRIMINATOR.len());
        if disc != Self::DISCRIMINATOR {
            return None;
        }
        BorshDeserialize::deserialize(&mut rest).ok()
    }
}

impl StarbasePlayer {
    pub fn decode(data: &[u8]) -> Option<Self> {
        <Self as carbon_core::deserialize::CarbonDeserialize>::deserialize(data)
    }
}
