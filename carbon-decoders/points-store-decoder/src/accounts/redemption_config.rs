//! This code was AUTOGENERATED using the Codama library.
use carbon_core::borsh::{self, BorshDeserialize};
use solana_pubkey::Pubkey;

use crate::types::RedemptionEpoch;

/// Configuration to allow use of points to redeem tokens.

#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, PartialEq)]
pub struct RedemptionConfig {
    /// The version of data in this struct.
    pub version: u8,
    /// The category of points that can be used to redeem tokens
    pub point_category: Pubkey,
    /// The [`Profile`] that handles the points store program permissions
    pub profile: Pubkey,
    /// The faction
    pub faction: u8,
    /// The token account that stores the redeemable tokens.
    pub bank: Pubkey,
    /// The bump of the signer for the points store.
    pub signer_bump: u8,
    /// Allow only the current epoch to be redeemed
    pub allow_only_current_epoch: u8,
    /// RemainingData: UnorderedList<RedemptionEpoch, u32>
    pub redemption_epochs: Vec<RedemptionEpoch>,
}

impl borsh::de::BorshDeserialize for RedemptionConfig
where
    u8: borsh::BorshDeserialize,
    Pubkey: borsh::BorshDeserialize,
{
    fn deserialize_reader<R: borsh::io::Read>(reader: &mut R) -> Result<Self, borsh::io::Error> {
        Ok(Self {
            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
            point_category: borsh::BorshDeserialize::deserialize_reader(reader)?,
            profile: borsh::BorshDeserialize::deserialize_reader(reader)?,
            faction: borsh::BorshDeserialize::deserialize_reader(reader)?,
            bank: borsh::BorshDeserialize::deserialize_reader(reader)?,
            signer_bump: borsh::BorshDeserialize::deserialize_reader(reader)?,
            allow_only_current_epoch: borsh::BorshDeserialize::deserialize_reader(reader)?,
            redemption_epochs: Vec::new(), // Will be populated by CarbonDeserialize
        })
    }
}

impl carbon_core::deserialize::CarbonDeserialize for RedemptionConfig {
    const DISCRIMINATOR: &'static [u8] = &[173u8, 1u8, 86u8, 47u8, 27u8, 204u8, 146u8, 185u8];

    fn deserialize(data: &[u8]) -> Option<Self> {
        // RedemptionConfig has RemainingData = UnorderedList<RedemptionEpoch, u32>
        // Contains a u32 length prefix followed by that many RedemptionEpoch structs

        let mut rest = data;

        let mut redemption_config: RedemptionConfig = match BorshDeserialize::deserialize(&mut rest)
        {
            Ok(res) => res,
            Err(_) => return None,
        };

        // Read u32 length prefix
        let epochs_count: u32 = match BorshDeserialize::deserialize(&mut rest) {
            Ok(count) => count,
            Err(_) => return None,
        };

        // Read each RedemptionEpoch
        let mut redemption_epochs = Vec::with_capacity(epochs_count as usize);
        for _ in 0..epochs_count {
            let epoch: RedemptionEpoch = match BorshDeserialize::deserialize(&mut rest) {
                Ok(e) => e,
                Err(_) => return None,
            };
            redemption_epochs.push(epoch);
        }

        redemption_config.redemption_epochs = redemption_epochs;

        Some(redemption_config)
    }
}

impl RedemptionConfig {
    pub fn decode(data: &[u8]) -> Option<Self> {
        use carbon_core::deserialize::CarbonDeserialize;

        if data.len() < 8 {
            return None;
        }
        let discriminator = &data[0..8];
        if discriminator != Self::DISCRIMINATOR {
            return None;
        }

        let data_slice = &data[8..];
        <RedemptionConfig as CarbonDeserialize>::deserialize(data_slice)
    }
}
