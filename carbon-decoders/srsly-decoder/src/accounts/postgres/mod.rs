//! This code was AUTOGENERATED using the Codama library.
pub mod contract_state_row;
pub mod fleet_row;
pub mod rental_state_row;
pub mod thread_row;

pub use self::contract_state_row::*;
pub use self::fleet_row::*;
pub use self::rental_state_row::*;
pub use self::thread_row::*;

use super::SrslyAccount;

pub struct SrslyAccountsMigration;

impl sqlx_migrator::Migration<sqlx::Postgres> for SrslyAccountsMigration {
    fn app(&self) -> &str {
        "srsly"
    }

    fn name(&self) -> &str {
        "srsly_accounts"
    }

    fn operations(&self) -> Vec<Box<dyn sqlx_migrator::Operation<sqlx::Postgres>>> {
        vec![
            Box::new(ContractStateMigrationOperation),
            Box::new(FleetMigrationOperation),
            Box::new(RentalStateMigrationOperation),
            Box::new(ThreadMigrationOperation),
        ]
    }

    fn parents(&self) -> Vec<Box<dyn sqlx_migrator::Migration<sqlx::Postgres>>> {
        vec![]
    }
}

pub struct SrslyAccountWithMetadata(pub SrslyAccount, pub carbon_core::account::AccountMetadata);

impl From<(SrslyAccount, carbon_core::account::AccountMetadata)> for SrslyAccountWithMetadata {
    fn from(value: (SrslyAccount, carbon_core::account::AccountMetadata)) -> Self {
        SrslyAccountWithMetadata(value.0, value.1)
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Insert for SrslyAccountWithMetadata {
    async fn insert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let SrslyAccountWithMetadata(account, metadata) = self;

        match account {
            SrslyAccount::ContractState(account) => {
                let row = contract_state_row::ContractStateRow::from_parts(
                    *account.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            SrslyAccount::Fleet(account) => {
                let row = fleet_row::FleetRow::from_parts(*account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            SrslyAccount::RentalState(account) => {
                let row = rental_state_row::RentalStateRow::from_parts(
                    *account.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            SrslyAccount::Thread(account) => {
                let row = thread_row::ThreadRow::from_parts(*account.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
        }
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Upsert for SrslyAccountWithMetadata {
    async fn upsert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let SrslyAccountWithMetadata(account, metadata) = self;
        match account {
            SrslyAccount::ContractState(account) => {
                let row = contract_state_row::ContractStateRow::from_parts(
                    *account.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            SrslyAccount::Fleet(account) => {
                let row = fleet_row::FleetRow::from_parts(*account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            SrslyAccount::RentalState(account) => {
                let row = rental_state_row::RentalStateRow::from_parts(
                    *account.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            SrslyAccount::Thread(account) => {
                let row = thread_row::ThreadRow::from_parts(*account.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
        }
    }
}
