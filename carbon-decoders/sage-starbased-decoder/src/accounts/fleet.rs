//! This code was AUTOGENERATED using the Codama library.
use crate::types::Idle;
use crate::types::MineAsteroid;
use crate::types::MoveSubwarp;
use crate::types::MoveWarp;
use crate::types::OptionalNonSystemPubkey;
use crate::types::Respawn;
use crate::types::ShipCounts;
use crate::types::ShipStats;
use crate::types::StarbaseLoadingBay;
use carbon_core::borsh;
use carbon_core::borsh::BorshDeserialize;
use solana_pubkey::Pubkey;

/// A `SAGE` fleet.

#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, PartialEq)]
pub struct Fleet {
    /// The data version of this account.
    pub version: u8,
    /// The game id this belongs to.
    pub game_id: Pubkey,
    /// The owner's profile.
    pub owner_profile: Pubkey,
    /// Fleet Ships Key
    pub fleet_ships: Pubkey,
    /// The fleet's sub-authority.
    /// If [`Some`] will have the exclusive ability to interact with this fleet.
    pub sub_profile: OptionalNonSystemPubkey,
    /// The authority for revoking a sun-authority.
    pub sub_profile_invalidator: Pubkey,
    /// The faction of the profile.
    pub faction: u8,
    /// The label or name of the fleet.
    pub fleet_label: [u8; 32],
    /// The number of ships in the fleet.
    pub ship_counts: ShipCounts,
    /// The time at which the warp cooldown expires
    pub warp_cooldown_expires_at: i64,
    /// The time at which the scan cooldown expires
    pub scan_cooldown_expires_at: i64,
    /// The fleet's stats.
    pub stats: ShipStats,
    /// The Cargo pod representing the fleet's cargo hold
    pub cargo_hold: Pubkey,
    /// The Cargo pod representing the fleet's fuel tank
    pub fuel_tank: Pubkey,
    /// The Cargo pod representing the fleet's ammo bank
    pub ammo_bank: Pubkey,
    /// The update id for the `Fleet`
    pub update_id: u64,
    /// The fleet's bump.
    pub bump: u8,
    /// The fleet's current state (remaining data)
    pub fleet_state: FleetState,
}

/// The state of the fleet
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, PartialEq, BorshDeserialize)]
pub enum FleetState {
    StarbaseLoadingBay(StarbaseLoadingBay),
    Idle(Idle),
    MineAsteroid(MineAsteroid),
    MoveWarp(MoveWarp),
    MoveSubwarp(MoveSubwarp),
    Respawn(Respawn),
}

impl borsh::de::BorshDeserialize for Fleet {
    fn deserialize_reader<R: borsh::io::Read>(reader: &mut R) -> Result<Self, borsh::io::Error> {
        Ok(Self {
            version: BorshDeserialize::deserialize_reader(reader)?,
            game_id: BorshDeserialize::deserialize_reader(reader)?,
            owner_profile: BorshDeserialize::deserialize_reader(reader)?,
            fleet_ships: BorshDeserialize::deserialize_reader(reader)?,
            sub_profile: BorshDeserialize::deserialize_reader(reader)?,
            sub_profile_invalidator: BorshDeserialize::deserialize_reader(reader)?,
            faction: BorshDeserialize::deserialize_reader(reader)?,
            fleet_label: BorshDeserialize::deserialize_reader(reader)?,
            ship_counts: BorshDeserialize::deserialize_reader(reader)?,
            warp_cooldown_expires_at: BorshDeserialize::deserialize_reader(reader)?,
            scan_cooldown_expires_at: BorshDeserialize::deserialize_reader(reader)?,
            stats: BorshDeserialize::deserialize_reader(reader)?,
            cargo_hold: BorshDeserialize::deserialize_reader(reader)?,
            fuel_tank: BorshDeserialize::deserialize_reader(reader)?,
            ammo_bank: BorshDeserialize::deserialize_reader(reader)?,
            update_id: BorshDeserialize::deserialize_reader(reader)?,
            bump: BorshDeserialize::deserialize_reader(reader)?,
            fleet_state: BorshDeserialize::deserialize_reader(reader)?,
        })
    }
}

impl carbon_core::deserialize::CarbonDeserialize for Fleet {
    const DISCRIMINATOR: &'static [u8] = &[109u8, 207u8, 251u8, 48u8, 106u8, 2u8, 136u8, 163u8];

    fn deserialize(data: &[u8]) -> Option<Self> {
        if data.len() < Self::DISCRIMINATOR.len() {
            return None;
        }
        let (disc, mut rest) = data.split_at(Self::DISCRIMINATOR.len());
        if disc != Self::DISCRIMINATOR {
            return None;
        }
        BorshDeserialize::deserialize(&mut rest).ok()
    }
}

impl Fleet {
    pub fn decode(data: &[u8]) -> Option<Self> {
        <Self as carbon_core::deserialize::CarbonDeserialize>::deserialize(data)
    }
}
