//! This code was AUTOGENERATED using the Codama library.
use carbon_core::borsh::{self, BorshDeserialize};
use solana_pubkey::Pubkey;

/// A pod that can store any number of resources and tracks stats given a definition.

#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, PartialEq)]
pub struct CargoPod {
    /// The data version of this account.
    pub version: u8,
    /// The definition of tracked stats.
    pub stats_definition: Pubkey,
    /// The authority for this pod.
    pub authority: Pubkey,
    /// The number of open token accounts in this pod.
    pub open_token_accounts: u8,
    /// The seeds of the signer for this pod.
    pub pod_seeds: [u8; 32],
    /// The bump of the signer for this pod.
    pub pod_bump: u8,
    /// The sequence id for the definition
    pub seq_id: u16,
    /// The number of unupdated token accounts in this pod. If this is greater than zero means the pod is frozen and only can withdraw cargo but not deposit.
    pub unupdated_token_accounts: u8,
    /// RemainingData: List<PackedValue<u64>>
    pub cargo_contents: Vec<u64>,
}

impl borsh::de::BorshDeserialize for CargoPod
where
    u8: borsh::BorshDeserialize,
    Pubkey: borsh::BorshDeserialize,
    u16: borsh::BorshDeserialize,
{
    fn deserialize_reader<R: borsh::io::Read>(reader: &mut R) -> Result<Self, borsh::io::Error> {
        Ok(Self {
            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
            stats_definition: borsh::BorshDeserialize::deserialize_reader(reader)?,
            authority: borsh::BorshDeserialize::deserialize_reader(reader)?,
            open_token_accounts: borsh::BorshDeserialize::deserialize_reader(reader)?,
            pod_seeds: borsh::BorshDeserialize::deserialize_reader(reader)?,
            pod_bump: borsh::BorshDeserialize::deserialize_reader(reader)?,
            seq_id: borsh::BorshDeserialize::deserialize_reader(reader)?,
            unupdated_token_accounts: borsh::BorshDeserialize::deserialize_reader(reader)?,
            cargo_contents: Vec::new(), // Will be populated by CarbonDeserialize
        })
    }
}

impl carbon_core::deserialize::CarbonDeserialize for CargoPod {
    const DISCRIMINATOR: &'static [u8] = &[165u8, 33u8, 118u8, 235u8, 252u8, 188u8, 244u8, 93u8];

    fn deserialize(data: &[u8]) -> Option<Self> {
        // CargoPod has RemainingData = List<PackedValue<u64>>
        // Contains the contents of the cargo pod as a list of u64 (no length prefix in account)
        // Byte layout: version(1) + stats_definition(32) + authority(32) + open_token_accounts(1) + pod_seeds(32) + pod_bump(1) + seq_id(2) + unupdated_token_accounts(1) = 102 bytes
        // All remaining bytes after fixed fields are u64 cargo values

        let mut rest = data;

        let mut cargo_pod: CargoPod = match BorshDeserialize::deserialize(&mut rest) {
            Ok(res) => res,
            Err(_) => return None,
        };

        // Read all remaining bytes as u64 values (each u64 is 8 bytes)
        let num_u64_values = rest.len() / 8;
        let mut cargo_contents = Vec::with_capacity(num_u64_values);

        for _ in 0..num_u64_values {
            let value: u64 = match BorshDeserialize::deserialize(&mut rest) {
                Ok(v) => v,
                Err(_) => return None,
            };
            cargo_contents.push(value);
        }

        cargo_pod.cargo_contents = cargo_contents;

        Some(cargo_pod)
    }
}

impl CargoPod {
    pub fn decode(data: &[u8]) -> Option<Self> {
        use carbon_core::deserialize::CarbonDeserialize;

        if data.len() < 8 {
            return None;
        }
        let discriminator = &data[0..8];
        if discriminator != Self::DISCRIMINATOR {
            return None;
        }

        let data_slice = &data[8..];
        <CargoPod as CarbonDeserialize>::deserialize(data_slice)
    }
}
