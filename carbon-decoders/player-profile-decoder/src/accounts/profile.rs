//! This code was AUTOGENERATED using the Codama library.
use carbon_core::borsh::{self, BorshDeserialize};

use crate::types::ProfileKey;

/// A player profile.

#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, PartialEq)]
pub struct Profile {
    /// The data version of this account.
    pub version: u8,
    /// The number of auth keys on the account
    pub auth_key_count: u16,
    /// The number of auth keys needed to update the profile.
    pub key_threshold: u8,
    /// The next sequence number for a new role.
    pub next_seq_id: u64,
    /// When the profile was created.
    pub created_at: i64,
    /// RemainingData: UnorderedList<ProfileKey, u16>
    pub profile_keys: Vec<ProfileKey>,
}

impl borsh::de::BorshDeserialize for Profile
where
    u8: borsh::BorshDeserialize,
    u16: borsh::BorshDeserialize,
    u64: borsh::BorshDeserialize,
    i64: borsh::BorshDeserialize,
{
    fn deserialize_reader<R: borsh::io::Read>(reader: &mut R) -> Result<Self, borsh::io::Error> {
        Ok(Self {
            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
            auth_key_count: borsh::BorshDeserialize::deserialize_reader(reader)?,
            key_threshold: borsh::BorshDeserialize::deserialize_reader(reader)?,
            next_seq_id: borsh::BorshDeserialize::deserialize_reader(reader)?,
            created_at: borsh::BorshDeserialize::deserialize_reader(reader)?,
            profile_keys: Vec::new(), // Will be populated by CarbonDeserialize
        })
    }
}

impl carbon_core::deserialize::CarbonDeserialize for Profile {
    const DISCRIMINATOR: &'static [u8] = &[184u8, 101u8, 165u8, 188u8, 95u8, 63u8, 127u8, 188u8];

    fn deserialize(data: &[u8]) -> Option<Self> {
        // Profile has RemainingData = UnorderedList<ProfileKey, u16>
        // The u16 length prefix is stored after the fixed fields (20 bytes total)
        // Byte layout: version(1) + auth_key_count(2) + key_threshold(1) + next_seq_id(8) + created_at(8) = 20 bytes

        let mut rest = data;

        let profile: Profile = match BorshDeserialize::deserialize(&mut rest) {
            Ok(res) => res,
            Err(_) => return None,
        };

        // Read u16 length prefix
        let list_length: u16 = match BorshDeserialize::deserialize(&mut rest) {
            Ok(count) => count,
            Err(_) => return None,
        };

        // Read each ProfileKey
        let mut profile_keys = Vec::with_capacity(list_length as usize);
        for _ in 0..list_length {
            let key: ProfileKey = match BorshDeserialize::deserialize(&mut rest) {
                Ok(k) => k,
                Err(_) => return None,
            };
            profile_keys.push(key);
        }

        let mut final_profile = profile;
        final_profile.profile_keys = profile_keys;

        Some(final_profile)
    }
}

impl Profile {
    pub fn decode(data: &[u8]) -> Option<Self> {
        use carbon_core::deserialize::CarbonDeserialize;

        if data.len() < 8 {
            return None;
        }
        let discriminator = &data[0..8];
        if discriminator != Self::DISCRIMINATOR {
            return None;
        }

        let data_slice = &data[8..];
        <Profile as CarbonDeserialize>::deserialize(data_slice)
    }
}
