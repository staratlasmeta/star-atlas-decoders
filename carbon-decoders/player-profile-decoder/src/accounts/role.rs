//! This code was AUTOGENERATED using the Codama library.
use carbon_core::borsh::{self, BorshDeserialize};
use solana_pubkey::Pubkey;

use crate::types::RoleMembership;

/// A Role associated with a Profile. A Role contains an unordered list of Role Members in its
/// remaining data which lists all of the members who carry this role.

#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, PartialEq)]
pub struct Role {
    /// The data version of this account.
    pub version: u8,
    /// Profile that this role belongs to
    pub profile: Pubkey,
    /// Origin authority of the account
    pub authorizer: Pubkey,
    /// Role's seq_id
    pub role_seq_id: u64,
    /// Is role accepting new members
    pub accepting_new_members: u8,
    /// The name of the rank
    /// TODO: Add instruction to use `player-name` as the label
    /// PDA bump
    pub bump: u8,
    /// RemainingData: UnorderedList<RoleMembership, u32>
    pub members: Vec<RoleMembership>,
}

impl borsh::de::BorshDeserialize for Role
where
    u8: borsh::BorshDeserialize,
    Pubkey: borsh::BorshDeserialize,
    u64: borsh::BorshDeserialize,
{
    fn deserialize_reader<R: borsh::io::Read>(reader: &mut R) -> Result<Self, borsh::io::Error> {
        Ok(Self {
            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
            profile: borsh::BorshDeserialize::deserialize_reader(reader)?,
            authorizer: borsh::BorshDeserialize::deserialize_reader(reader)?,
            role_seq_id: borsh::BorshDeserialize::deserialize_reader(reader)?,
            accepting_new_members: borsh::BorshDeserialize::deserialize_reader(reader)?,
            bump: borsh::BorshDeserialize::deserialize_reader(reader)?,
            members: Vec::new(), // Will be populated by CarbonDeserialize
        })
    }
}

impl carbon_core::deserialize::CarbonDeserialize for Role {
    const DISCRIMINATOR: &'static [u8] = &[46u8, 219u8, 197u8, 24u8, 233u8, 249u8, 253u8, 154u8];

    fn deserialize(data: &[u8]) -> Option<Self> {
        // Role has RemainingData = UnorderedList<RoleMembership, u32>
        // The u32 length prefix is stored after the fixed fields (75 bytes total)
        // Byte layout: version(1) + profile(32) + authorizer(32) + role_seq_id(8) + accepting_new_members(1) + bump(1) = 75 bytes

        let mut rest = data;

        let role: Role = match BorshDeserialize::deserialize(&mut rest) {
            Ok(res) => res,
            Err(_) => return None,
        };

        // Read u32 length prefix
        let list_length: u32 = match BorshDeserialize::deserialize(&mut rest) {
            Ok(count) => count,
            Err(_) => return None,
        };

        // Read each RoleMembership
        let mut members = Vec::with_capacity(list_length as usize);
        for _ in 0..list_length {
            let member: RoleMembership = match BorshDeserialize::deserialize(&mut rest) {
                Ok(m) => m,
                Err(_) => return None,
            };
            members.push(member);
        }

        let mut final_role = role;
        final_role.members = members;

        Some(final_role)
    }
}

impl Role {
    pub fn decode(data: &[u8]) -> Option<Self> {
        use carbon_core::deserialize::CarbonDeserialize;

        if data.len() < 8 {
            return None;
        }
        let discriminator = &data[0..8];
        if discriminator != Self::DISCRIMINATOR {
            return None;
        }

        let data_slice = &data[8..];
        <Role as CarbonDeserialize>::deserialize(data_slice)
    }
}
