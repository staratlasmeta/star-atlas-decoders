//! This code was AUTOGENERATED using the Codama library.
use carbon_core::borsh::{self, BorshDeserialize};
use solana_pubkey::Pubkey;

/// Stores a player's name on-chain.

#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, PartialEq)]
pub struct PlayerName {
    /// The data version of this account.
    pub version: u8,
    /// The profile this name is for.
    pub profile: Pubkey,
    /// The bump for this account.
    pub bump: u8,
    /// RemainingData: Bytes (the player's name)
    pub name: Vec<u8>,
}

impl borsh::de::BorshDeserialize for PlayerName
where
    u8: borsh::BorshDeserialize,
    Pubkey: borsh::BorshDeserialize,
{
    fn deserialize_reader<R: borsh::io::Read>(reader: &mut R) -> Result<Self, borsh::io::Error> {
        Ok(Self {
            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
            profile: borsh::BorshDeserialize::deserialize_reader(reader)?,
            bump: borsh::BorshDeserialize::deserialize_reader(reader)?,
            name: Vec::new(), // Will be populated by CarbonDeserialize
        })
    }
}

impl carbon_core::deserialize::CarbonDeserialize for PlayerName {
    const DISCRIMINATOR: &'static [u8] = &[102u8, 9u8, 241u8, 98u8, 96u8, 196u8, 212u8, 161u8];

    fn deserialize(data: &[u8]) -> Option<Self> {
        // PlayerName has RemainingData = Bytes (no length prefix, just raw bytes)
        // All remaining bytes after the fixed fields are the player's name
        // Fixed fields: version(1) + profile(32) + bump(1) = 34 bytes

        let mut rest = data;

        let mut player_name: PlayerName = match BorshDeserialize::deserialize(&mut rest) {
            Ok(res) => res,
            Err(_) => return None,
        };

        // All remaining bytes are the name
        player_name.name = rest.to_vec();

        Some(player_name)
    }
}

impl PlayerName {
    pub fn decode(data: &[u8]) -> Option<Self> {
        use carbon_core::deserialize::CarbonDeserialize;

        if data.len() < 8 {
            return None;
        }
        let discriminator = &data[0..8];
        if discriminator != Self::DISCRIMINATOR {
            return None;
        }

        let data_slice = &data[8..];
        <PlayerName as CarbonDeserialize>::deserialize(data_slice)
    }
}
