//! This code was AUTOGENERATED using the Codama library.
pub mod activate_proposal_row;
pub mod approve_program_lock_privilege_row;
pub mod cast_vote_row;
pub mod cpi_event_row;
pub mod exit_row;
pub mod lock_row;
pub mod lock_with_whitelist_entry_row;
pub mod new_escrow_row;
pub mod new_locker_row;
pub mod revoke_program_lock_privilege_row;
pub mod set_locker_params_row;
pub mod set_vote_delegate_row;

pub use self::activate_proposal_row::*;
pub use self::approve_program_lock_privilege_row::*;
pub use self::cast_vote_row::*;
pub use self::cpi_event_row::*;
pub use self::exit_row::*;
pub use self::lock_row::*;
pub use self::lock_with_whitelist_entry_row::*;
pub use self::new_escrow_row::*;
pub use self::new_locker_row::*;
pub use self::revoke_program_lock_privilege_row::*;
pub use self::set_locker_params_row::*;
pub use self::set_vote_delegate_row::*;

use super::LockedVoterInstruction;

pub struct LockedVoterInstructionsMigration;

impl sqlx_migrator::Migration<sqlx::Postgres> for LockedVoterInstructionsMigration {
    fn app(&self) -> &str {
        "locked-voter"
    }

    fn name(&self) -> &str {
        "locked_voter_instructions"
    }

    fn operations(&self) -> Vec<Box<dyn sqlx_migrator::Operation<sqlx::Postgres>>> {
        vec![
            Box::new(ActivateProposalMigrationOperation),
            Box::new(ApproveProgramLockPrivilegeMigrationOperation),
            Box::new(CastVoteMigrationOperation),
            Box::new(ExitMigrationOperation),
            Box::new(LockMigrationOperation),
            Box::new(LockWithWhitelistEntryMigrationOperation),
            Box::new(NewEscrowMigrationOperation),
            Box::new(NewLockerMigrationOperation),
            Box::new(RevokeProgramLockPrivilegeMigrationOperation),
            Box::new(SetLockerParamsMigrationOperation),
            Box::new(SetVoteDelegateMigrationOperation),
            Box::new(CpiEventMigrationOperation),
        ]
    }

    fn parents(&self) -> Vec<Box<dyn sqlx_migrator::Migration<sqlx::Postgres>>> {
        vec![]
    }
}

pub struct LockedVoterInstructionWithMetadata(
    pub LockedVoterInstruction,
    pub carbon_core::instruction::InstructionMetadata,
);

impl
    From<(
        LockedVoterInstruction,
        carbon_core::instruction::InstructionMetadata,
    )> for LockedVoterInstructionWithMetadata
{
    fn from(
        value: (
            LockedVoterInstruction,
            carbon_core::instruction::InstructionMetadata,
        ),
    ) -> Self {
        LockedVoterInstructionWithMetadata(value.0, value.1)
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Insert for LockedVoterInstructionWithMetadata {
    async fn insert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let LockedVoterInstructionWithMetadata(instruction, metadata) = self;
        match instruction {
            LockedVoterInstruction::NewLocker(instruction) => {
                let row =
                    new_locker_row::NewLockerRow::from_parts(instruction.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::NewEscrow(instruction) => {
                let row =
                    new_escrow_row::NewEscrowRow::from_parts(instruction.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::Lock(instruction) => {
                let row = lock_row::LockRow::from_parts(instruction.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::LockWithWhitelistEntry(instruction) => {
                let row = lock_with_whitelist_entry_row::LockWithWhitelistEntryRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::Exit(instruction) => {
                let row = exit_row::ExitRow::from_parts(instruction.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::ActivateProposal(instruction) => {
                let row = activate_proposal_row::ActivateProposalRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::CastVote(instruction) => {
                let row =
                    cast_vote_row::CastVoteRow::from_parts(instruction.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::SetVoteDelegate(instruction) => {
                let row = set_vote_delegate_row::SetVoteDelegateRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::SetLockerParams(instruction) => {
                let row = set_locker_params_row::SetLockerParamsRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::ApproveProgramLockPrivilege(instruction) => {
                let row =
                    approve_program_lock_privilege_row::ApproveProgramLockPrivilegeRow::from_parts(
                        instruction.clone(),
                        metadata.clone(),
                    );
                row.insert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::RevokeProgramLockPrivilege(instruction) => {
                let row =
                    revoke_program_lock_privilege_row::RevokeProgramLockPrivilegeRow::from_parts(
                        instruction.clone(),
                        metadata.clone(),
                    );
                row.insert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::CpiEvent(instruction) => {
                let row =
                    cpi_event_row::CpiEventRow::from_parts(instruction.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
        }
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Upsert for LockedVoterInstructionWithMetadata {
    async fn upsert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let LockedVoterInstructionWithMetadata(instruction, metadata) = self;
        match instruction {
            LockedVoterInstruction::NewLocker(instruction) => {
                let row =
                    new_locker_row::NewLockerRow::from_parts(instruction.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::NewEscrow(instruction) => {
                let row =
                    new_escrow_row::NewEscrowRow::from_parts(instruction.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::Lock(instruction) => {
                let row = lock_row::LockRow::from_parts(instruction.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::LockWithWhitelistEntry(instruction) => {
                let row = lock_with_whitelist_entry_row::LockWithWhitelistEntryRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::Exit(instruction) => {
                let row = exit_row::ExitRow::from_parts(instruction.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::ActivateProposal(instruction) => {
                let row = activate_proposal_row::ActivateProposalRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::CastVote(instruction) => {
                let row =
                    cast_vote_row::CastVoteRow::from_parts(instruction.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::SetVoteDelegate(instruction) => {
                let row = set_vote_delegate_row::SetVoteDelegateRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::SetLockerParams(instruction) => {
                let row = set_locker_params_row::SetLockerParamsRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::ApproveProgramLockPrivilege(instruction) => {
                let row =
                    approve_program_lock_privilege_row::ApproveProgramLockPrivilegeRow::from_parts(
                        instruction.clone(),
                        metadata.clone(),
                    );
                row.upsert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::RevokeProgramLockPrivilege(instruction) => {
                let row =
                    revoke_program_lock_privilege_row::RevokeProgramLockPrivilegeRow::from_parts(
                        instruction.clone(),
                        metadata.clone(),
                    );
                row.upsert(pool).await?;
                Ok(())
            }
            LockedVoterInstruction::CpiEvent(instruction) => {
                let row =
                    cpi_event_row::CpiEventRow::from_parts(instruction.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
        }
    }
}
