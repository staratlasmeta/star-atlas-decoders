//! This code was AUTOGENERATED using the Codama library.
pub mod cancel_unstake_row;
pub mod create_staking_account_row;
pub mod harvest_row;
pub mod initialize_staking_row;
pub mod register_stake_row;
pub mod settle_row;
pub mod stake_tokens_row;
pub mod unstake_tokens_row;
pub mod update_cooldown_period_row;
pub mod update_reward_multiplier_row;
pub mod withdraw_tokens_row;

pub use self::cancel_unstake_row::*;
pub use self::create_staking_account_row::*;
pub use self::harvest_row::*;
pub use self::initialize_staking_row::*;
pub use self::register_stake_row::*;
pub use self::settle_row::*;
pub use self::stake_tokens_row::*;
pub use self::unstake_tokens_row::*;
pub use self::update_cooldown_period_row::*;
pub use self::update_reward_multiplier_row::*;
pub use self::withdraw_tokens_row::*;

use super::AtlasStakingInstruction;

pub struct AtlasStakingInstructionsMigration;

impl sqlx_migrator::Migration<sqlx::Postgres> for AtlasStakingInstructionsMigration {
    fn app(&self) -> &str {
        "atlas-staking"
    }

    fn name(&self) -> &str {
        "atlas_staking_instructions"
    }

    fn operations(&self) -> Vec<Box<dyn sqlx_migrator::Operation<sqlx::Postgres>>> {
        vec![
            Box::new(CancelUnstakeMigrationOperation),
            Box::new(CreateStakingAccountMigrationOperation),
            Box::new(HarvestMigrationOperation),
            Box::new(InitializeStakingMigrationOperation),
            Box::new(RegisterStakeMigrationOperation),
            Box::new(SettleMigrationOperation),
            Box::new(StakeTokensMigrationOperation),
            Box::new(UnstakeTokensMigrationOperation),
            Box::new(UpdateCooldownPeriodMigrationOperation),
            Box::new(UpdateRewardMultiplierMigrationOperation),
            Box::new(WithdrawTokensMigrationOperation),
        ]
    }

    fn parents(&self) -> Vec<Box<dyn sqlx_migrator::Migration<sqlx::Postgres>>> {
        vec![]
    }
}

pub struct AtlasStakingInstructionWithMetadata(
    pub AtlasStakingInstruction,
    pub carbon_core::instruction::InstructionMetadata,
);

impl
    From<(
        AtlasStakingInstruction,
        carbon_core::instruction::InstructionMetadata,
    )> for AtlasStakingInstructionWithMetadata
{
    fn from(
        value: (
            AtlasStakingInstruction,
            carbon_core::instruction::InstructionMetadata,
        ),
    ) -> Self {
        AtlasStakingInstructionWithMetadata(value.0, value.1)
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Insert for AtlasStakingInstructionWithMetadata {
    async fn insert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let AtlasStakingInstructionWithMetadata(instruction, metadata) = self;
        match instruction {
            AtlasStakingInstruction::CancelUnstake(instruction) => {
                let row = cancel_unstake_row::CancelUnstakeRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::CreateStakingAccount(instruction) => {
                let row = create_staking_account_row::CreateStakingAccountRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::Harvest(instruction) => {
                let row =
                    harvest_row::HarvestRow::from_parts(instruction.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::InitializeStaking(instruction) => {
                let row = initialize_staking_row::InitializeStakingRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::RegisterStake(instruction) => {
                let row = register_stake_row::RegisterStakeRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::Settle(instruction) => {
                let row = settle_row::SettleRow::from_parts(instruction.clone(), metadata.clone());
                row.insert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::StakeTokens(instruction) => {
                let row = stake_tokens_row::StakeTokensRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::UnstakeTokens(instruction) => {
                let row = unstake_tokens_row::UnstakeTokensRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::UpdateCooldownPeriod(instruction) => {
                let row = update_cooldown_period_row::UpdateCooldownPeriodRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::UpdateRewardMultiplier(instruction) => {
                let row = update_reward_multiplier_row::UpdateRewardMultiplierRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::WithdrawTokens(instruction) => {
                let row = withdraw_tokens_row::WithdrawTokensRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.insert(pool).await?;
                Ok(())
            }
        }
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Upsert for AtlasStakingInstructionWithMetadata {
    async fn upsert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        let AtlasStakingInstructionWithMetadata(instruction, metadata) = self;
        match instruction {
            AtlasStakingInstruction::CancelUnstake(instruction) => {
                let row = cancel_unstake_row::CancelUnstakeRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::CreateStakingAccount(instruction) => {
                let row = create_staking_account_row::CreateStakingAccountRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::Harvest(instruction) => {
                let row =
                    harvest_row::HarvestRow::from_parts(instruction.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::InitializeStaking(instruction) => {
                let row = initialize_staking_row::InitializeStakingRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::RegisterStake(instruction) => {
                let row = register_stake_row::RegisterStakeRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::Settle(instruction) => {
                let row = settle_row::SettleRow::from_parts(instruction.clone(), metadata.clone());
                row.upsert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::StakeTokens(instruction) => {
                let row = stake_tokens_row::StakeTokensRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::UnstakeTokens(instruction) => {
                let row = unstake_tokens_row::UnstakeTokensRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::UpdateCooldownPeriod(instruction) => {
                let row = update_cooldown_period_row::UpdateCooldownPeriodRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::UpdateRewardMultiplier(instruction) => {
                let row = update_reward_multiplier_row::UpdateRewardMultiplierRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
            AtlasStakingInstruction::WithdrawTokens(instruction) => {
                let row = withdraw_tokens_row::WithdrawTokensRow::from_parts(
                    instruction.clone(),
                    metadata.clone(),
                );
                row.upsert(pool).await?;
                Ok(())
            }
        }
    }
}
