//! This code was AUTOGENERATED using the Codama library.
use carbon_core::account::AccountMetadata;
use carbon_core::postgres::metadata::AccountRowMetadata;
use carbon_core::postgres::primitives::Pubkey;
use carbon_core::postgres::primitives::U8;
use carbon_core::postgres::primitives::U32;

#[derive(sqlx::FromRow, Debug, Clone)]
pub struct PackTiersRow {
    #[sqlx(flatten)]
    pub account_metadata: AccountRowMetadata,
    pub version: U8,
    pub crew_config: Pubkey,
    pub seed_pubkey: Pubkey,
    pub tier: U8,
    pub bump: U8,
    pub common: U32,
    pub uncommon: U32,
    pub rare: U32,
    pub epic: U32,
    pub legendary: U32,
    pub anomaly: U32,
}

impl PackTiersRow {
    pub fn from_parts(
        source: crate::accounts::pack_tiers::PackTiers,
        metadata: AccountMetadata,
    ) -> Self {
        Self {
            account_metadata: metadata.into(),
            version: source.version.into(),
            crew_config: source.crew_config.into(),
            seed_pubkey: source.seed_pubkey.into(),
            tier: source.tier.into(),
            bump: source.bump.into(),
            common: source.common.into(),
            uncommon: source.uncommon.into(),
            rare: source.rare.into(),
            epic: source.epic.into(),
            legendary: source.legendary.into(),
            anomaly: source.anomaly.into(),
        }
    }
}

impl TryFrom<PackTiersRow> for crate::accounts::pack_tiers::PackTiers {
    type Error = carbon_core::error::Error;
    fn try_from(source: PackTiersRow) -> Result<Self, Self::Error> {
        Ok(Self {
            version: source.version.try_into().map_err(|_| {
                carbon_core::error::Error::Custom(
                    "Failed to convert value from postgres primitive".to_string(),
                )
            })?,
            crew_config: *source.crew_config,
            seed_pubkey: *source.seed_pubkey,
            tier: source.tier.try_into().map_err(|_| {
                carbon_core::error::Error::Custom(
                    "Failed to convert value from postgres primitive".to_string(),
                )
            })?,
            bump: source.bump.try_into().map_err(|_| {
                carbon_core::error::Error::Custom(
                    "Failed to convert value from postgres primitive".to_string(),
                )
            })?,
            common: source.common.try_into().map_err(|_| {
                carbon_core::error::Error::Custom(
                    "Failed to convert value from postgres primitive".to_string(),
                )
            })?,
            uncommon: source.uncommon.try_into().map_err(|_| {
                carbon_core::error::Error::Custom(
                    "Failed to convert value from postgres primitive".to_string(),
                )
            })?,
            rare: source.rare.try_into().map_err(|_| {
                carbon_core::error::Error::Custom(
                    "Failed to convert value from postgres primitive".to_string(),
                )
            })?,
            epic: source.epic.try_into().map_err(|_| {
                carbon_core::error::Error::Custom(
                    "Failed to convert value from postgres primitive".to_string(),
                )
            })?,
            legendary: source.legendary.try_into().map_err(|_| {
                carbon_core::error::Error::Custom(
                    "Failed to convert value from postgres primitive".to_string(),
                )
            })?,
            anomaly: source.anomaly.try_into().map_err(|_| {
                carbon_core::error::Error::Custom(
                    "Failed to convert value from postgres primitive".to_string(),
                )
            })?,
        })
    }
}

impl carbon_core::postgres::operations::Table for crate::accounts::pack_tiers::PackTiers {
    fn table() -> &'static str {
        "pack_tiers_account"
    }

    fn columns() -> Vec<&'static str> {
        vec![
            "__pubkey",
            "__slot",
            "version",
            "crew_config",
            "seed_pubkey",
            "tier",
            "bump",
            "common",
            "uncommon",
            "rare",
            "epic",
            "legendary",
            "anomaly",
        ]
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Insert for PackTiersRow {
    async fn insert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        sqlx::query(
            r#"
            INSERT INTO pack_tiers_account (
                "version",
                "crew_config",
                "seed_pubkey",
                "tier",
                "bump",
                "common",
                "uncommon",
                "rare",
                "epic",
                "legendary",
                "anomaly",
                __pubkey, __slot
            ) VALUES (
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
            )"#,
        )
        .bind(self.version.clone())
        .bind(self.crew_config.clone())
        .bind(self.seed_pubkey.clone())
        .bind(self.tier.clone())
        .bind(self.bump.clone())
        .bind(self.common.clone())
        .bind(self.uncommon.clone())
        .bind(self.rare.clone())
        .bind(self.epic.clone())
        .bind(self.legendary.clone())
        .bind(self.anomaly.clone())
        .bind(self.account_metadata.pubkey.clone())
        .bind(self.account_metadata.slot.clone())
        .execute(pool)
        .await
        .map_err(|e| carbon_core::error::Error::Custom(e.to_string()))?;
        Ok(())
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Upsert for PackTiersRow {
    async fn upsert(&self, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        sqlx::query(
            r#"INSERT INTO pack_tiers_account (
                "version",
                "crew_config",
                "seed_pubkey",
                "tier",
                "bump",
                "common",
                "uncommon",
                "rare",
                "epic",
                "legendary",
                "anomaly",
                __pubkey, __slot
            ) VALUES (
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
            ) ON CONFLICT (
                __pubkey
            ) DO UPDATE SET
                "version" = EXCLUDED."version",
                "crew_config" = EXCLUDED."crew_config",
                "seed_pubkey" = EXCLUDED."seed_pubkey",
                "tier" = EXCLUDED."tier",
                "bump" = EXCLUDED."bump",
                "common" = EXCLUDED."common",
                "uncommon" = EXCLUDED."uncommon",
                "rare" = EXCLUDED."rare",
                "epic" = EXCLUDED."epic",
                "legendary" = EXCLUDED."legendary",
                "anomaly" = EXCLUDED."anomaly",
                __slot = EXCLUDED.__slot
            "#,
        )
        .bind(self.version.clone())
        .bind(self.crew_config.clone())
        .bind(self.seed_pubkey.clone())
        .bind(self.tier.clone())
        .bind(self.bump.clone())
        .bind(self.common.clone())
        .bind(self.uncommon.clone())
        .bind(self.rare.clone())
        .bind(self.epic.clone())
        .bind(self.legendary.clone())
        .bind(self.anomaly.clone())
        .bind(self.account_metadata.pubkey)
        .bind(self.account_metadata.slot.clone())
        .execute(pool)
        .await
        .map_err(|e| carbon_core::error::Error::Custom(e.to_string()))?;
        Ok(())
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::Delete for PackTiersRow {
    type Key = carbon_core::postgres::primitives::Pubkey;

    async fn delete(key: Self::Key, pool: &sqlx::PgPool) -> carbon_core::error::CarbonResult<()> {
        sqlx::query(
            r#"DELETE FROM pack_tiers_account WHERE
                __pubkey = $1
            "#,
        )
        .bind(key)
        .execute(pool)
        .await
        .map_err(|e| carbon_core::error::Error::Custom(e.to_string()))?;
        Ok(())
    }
}

#[async_trait::async_trait]
impl carbon_core::postgres::operations::LookUp for PackTiersRow {
    type Key = carbon_core::postgres::primitives::Pubkey;

    async fn lookup(
        key: Self::Key,
        pool: &sqlx::PgPool,
    ) -> carbon_core::error::CarbonResult<Option<Self>> {
        let row = sqlx::query_as(
            r#"SELECT * FROM pack_tiers_account WHERE
                __pubkey = $1
            "#,
        )
        .bind(key)
        .fetch_optional(pool)
        .await
        .map_err(|e| carbon_core::error::Error::Custom(e.to_string()))?;
        Ok(row)
    }
}

pub struct PackTiersMigrationOperation;

#[async_trait::async_trait]
impl sqlx_migrator::Operation<sqlx::Postgres> for PackTiersMigrationOperation {
    async fn up(
        &self,
        connection: &mut sqlx::PgConnection,
    ) -> Result<(), sqlx_migrator::error::Error> {
        sqlx::query(
            r#"CREATE TABLE IF NOT EXISTS pack_tiers_account (
                -- Account data
                "version" INT2 NOT NULL,
                "crew_config" BYTEA NOT NULL,
                "seed_pubkey" BYTEA NOT NULL,
                "tier" INT2 NOT NULL,
                "bump" INT2 NOT NULL,
                "common" INT8 NOT NULL,
                "uncommon" INT8 NOT NULL,
                "rare" INT8 NOT NULL,
                "epic" INT8 NOT NULL,
                "legendary" INT8 NOT NULL,
                "anomaly" INT8 NOT NULL,
                -- Account metadata
                __pubkey BYTEA NOT NULL,
                __slot NUMERIC(20),
                PRIMARY KEY (__pubkey)
            )"#,
        )
        .execute(connection)
        .await?;
        Ok(())
    }

    async fn down(
        &self,
        connection: &mut sqlx::PgConnection,
    ) -> Result<(), sqlx_migrator::error::Error> {
        sqlx::query(r#"DROP TABLE IF EXISTS pack_tiers_account"#)
            .execute(connection)
            .await?;
        Ok(())
    }
}
