//! This code was AUTOGENERATED using the Codama library.
use carbon_core::borsh::{self, BorshDeserialize};
use solana_pubkey::Pubkey;

use crate::types::{OptionalNonSystemPubkey, RecipeInputsOutputs, RecipeStatus};

/// The definition of a recipe.

#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Clone, PartialEq)]
pub struct Recipe {
    /// The data version of this account.
    pub version: u8,
    /// the domain
    pub domain: Pubkey,
    /// The Recipe Category
    pub category: Pubkey,
    /// TODO: remove this
    pub creator: Pubkey,
    /// The time required to craft this Recipe.
    pub duration: i64,
    /// The minimum time required to craft this Recipe.
    pub min_duration: i64,
    /// The name of this recipe.
    pub namespace: [u8; 32],
    /// The status of the recipe
    pub status: RecipeStatus,
    /// The amount to charge when this recipe is used
    pub fee_amount: u64,
    /// The token account that receives the `fee_amount`.  If [`None`] the recipe requires no fees when used.
    pub fee_recipient: OptionalNonSystemPubkey,
    /// The number of times that this recipe has been used
    pub usage_count: u64,
    /// The maximum number of times that this recipe can be used
    pub usage_limit: u64,
    /// The value of this recipe e.g. might be "economic value"
    /// The precise meaning of "value" is left to the person creating recipes to determine
    pub value: u64,
    /// The number of consumable inputs in this recipe.
    pub consumables_count: u8,
    /// The number of non-consumable inputs in this recipe.
    pub non_consumables_count: u8,
    /// The number of outputs from this recipe.
    pub outputs_count: u8,
    /// The number of all inputs and outputs in this recipe.
    pub total_count: u16,
    /// RemainingData: UnorderedList<RecipeInputsOutputs>
    pub recipe_items: Vec<RecipeInputsOutputs>,
}

impl borsh::de::BorshDeserialize for Recipe
where
    u8: borsh::BorshDeserialize,
    Pubkey: borsh::BorshDeserialize,
    i64: borsh::BorshDeserialize,
    RecipeStatus: borsh::BorshDeserialize,
    u64: borsh::BorshDeserialize,
    OptionalNonSystemPubkey: borsh::BorshDeserialize,
    u16: borsh::BorshDeserialize,
{
    fn deserialize_reader<R: borsh::io::Read>(reader: &mut R) -> Result<Self, borsh::io::Error> {
        Ok(Self {
            version: borsh::BorshDeserialize::deserialize_reader(reader)?,
            domain: borsh::BorshDeserialize::deserialize_reader(reader)?,
            category: borsh::BorshDeserialize::deserialize_reader(reader)?,
            creator: borsh::BorshDeserialize::deserialize_reader(reader)?,
            duration: borsh::BorshDeserialize::deserialize_reader(reader)?,
            min_duration: borsh::BorshDeserialize::deserialize_reader(reader)?,
            namespace: borsh::BorshDeserialize::deserialize_reader(reader)?,
            status: borsh::BorshDeserialize::deserialize_reader(reader)?,
            fee_amount: borsh::BorshDeserialize::deserialize_reader(reader)?,
            fee_recipient: borsh::BorshDeserialize::deserialize_reader(reader)?,
            usage_count: borsh::BorshDeserialize::deserialize_reader(reader)?,
            usage_limit: borsh::BorshDeserialize::deserialize_reader(reader)?,
            value: borsh::BorshDeserialize::deserialize_reader(reader)?,
            consumables_count: borsh::BorshDeserialize::deserialize_reader(reader)?,
            non_consumables_count: borsh::BorshDeserialize::deserialize_reader(reader)?,
            outputs_count: borsh::BorshDeserialize::deserialize_reader(reader)?,
            total_count: borsh::BorshDeserialize::deserialize_reader(reader)?,
            recipe_items: Vec::new(), // Will be populated by CarbonDeserialize
        })
    }
}

impl carbon_core::deserialize::CarbonDeserialize for Recipe {
    const DISCRIMINATOR: &'static [u8] = &[10u8, 162u8, 156u8, 100u8, 56u8, 193u8, 205u8, 77u8];

    fn deserialize(data: &[u8]) -> Option<Self> {
        // Recipe has RemainingData = UnorderedList<RecipeInputsOutputs>
        // Contains recipe inputs/outputs with amount and mint for each item
        // Byte layout: version(1) + domain(32) + category(32) + creator(32) + duration(8) + min_duration(8) + namespace(32) + status(1) + fee_amount(8) + fee_recipient(33) + usage_count(8) + usage_limit(8) + value(8) + consumables_count(1) + non_consumables_count(1) + outputs_count(1) + total_count(2) = 216 bytes
        // After fixed fields: total_count RecipeInputsOutputs structs (40 bytes each: 8 bytes for u64 amount + 32 bytes for Pubkey mint)

        let mut rest = data;

        let mut recipe: Recipe = match BorshDeserialize::deserialize(&mut rest) {
            Ok(res) => res,
            Err(_) => return None,
        };

        // Read total_count RecipeInputsOutputs from remaining data
        let total_count = recipe.total_count as usize;
        let mut recipe_items = Vec::with_capacity(total_count);

        for _ in 0..total_count {
            let item: RecipeInputsOutputs = match BorshDeserialize::deserialize(&mut rest) {
                Ok(i) => i,
                Err(_) => return None,
            };
            recipe_items.push(item);
        }

        recipe.recipe_items = recipe_items;

        Some(recipe)
    }
}

impl Recipe {
    pub fn decode(data: &[u8]) -> Option<Self> {
        use carbon_core::deserialize::CarbonDeserialize;

        if data.len() < 8 {
            return None;
        }
        let discriminator = &data[0..8];
        if discriminator != Self::DISCRIMINATOR {
            return None;
        }

        let data_slice = &data[8..];
        <Recipe as CarbonDeserialize>::deserialize(data_slice)
    }
}
