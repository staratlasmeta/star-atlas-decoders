//! This code was AUTOGENERATED using the Codama library.
use crate::CraftingDecoder;
use crate::PROGRAM_ID;

pub mod craftable_item;
pub mod crafting_facility;
pub mod crafting_process;
pub mod domain;
pub mod recipe;
pub mod recipe_category;

#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(tag = "type", content = "data"))]
pub enum CraftingAccount {
    CraftableItem(Box<craftable_item::CraftableItem>),
    CraftingFacility(Box<crafting_facility::CraftingFacility>),
    CraftingProcess(Box<crafting_process::CraftingProcess>),
    Domain(Box<domain::Domain>),
    Recipe(Box<recipe::Recipe>),
    RecipeCategory(Box<recipe_category::RecipeCategory>),
}

impl<'a> carbon_core::account::AccountDecoder<'a> for CraftingDecoder {
    type AccountType = CraftingAccount;

    fn decode_account(
        &self,
        account: &'a solana_account::Account,
    ) -> Option<carbon_core::account::DecodedAccount<Self::AccountType>> {
        if account.owner != PROGRAM_ID {
            return None;
        }

        let data = account.data.as_slice();

        {
            if let Some(decoded) = craftable_item::CraftableItem::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: CraftingAccount::CraftableItem(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = crafting_facility::CraftingFacility::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: CraftingAccount::CraftingFacility(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = crafting_process::CraftingProcess::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: CraftingAccount::CraftingProcess(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = domain::Domain::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: CraftingAccount::Domain(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = recipe::Recipe::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: CraftingAccount::Recipe(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }
        {
            if let Some(decoded) = recipe_category::RecipeCategory::decode(data) {
                return Some(carbon_core::account::DecodedAccount {
                    lamports: account.lamports,
                    data: CraftingAccount::RecipeCategory(Box::new(decoded)),
                    owner: account.owner,
                    executable: account.executable,
                    rent_epoch: account.rent_epoch,
                });
            }
        }

        None
    }
}
