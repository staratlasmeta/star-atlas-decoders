//! This code was AUTOGENERATED using the Codama library.
use juniper::{FieldResult, graphql_object};
use std::str::FromStr;

pub struct QueryRoot;

#[graphql_object(context = crate::graphql::context::GraphQLContext)]
impl QueryRoot {
    // Accounts
    async fn craftable_item(
        context: &crate::graphql::context::GraphQLContext,
        pubkey: String,
    ) -> FieldResult<Option<crate::accounts::graphql::CraftableItemGraphQL>> {
        use carbon_core::postgres::operations::LookUp;
        use carbon_core::postgres::primitives::Pubkey as PgPubkey;
        let pk = PgPubkey(
            solana_pubkey::Pubkey::from_str(&pubkey)
                .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?,
        );
        let row = crate::accounts::postgres::CraftableItemRow::lookup(pk, &context.pool)
            .await
            .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(row.map(|row| row.try_into().ok()).flatten())
    }

    async fn list_craftable_item(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::accounts::graphql::CraftableItemGraphQL>> {
        let rows: Vec<crate::accounts::postgres::CraftableItemRow> = sqlx::query_as(
            r#"SELECT * FROM craftable_item_account ORDER BY __slot DESC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn crafting_facility(
        context: &crate::graphql::context::GraphQLContext,
        pubkey: String,
    ) -> FieldResult<Option<crate::accounts::graphql::CraftingFacilityGraphQL>> {
        use carbon_core::postgres::operations::LookUp;
        use carbon_core::postgres::primitives::Pubkey as PgPubkey;
        let pk = PgPubkey(
            solana_pubkey::Pubkey::from_str(&pubkey)
                .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?,
        );
        let row = crate::accounts::postgres::CraftingFacilityRow::lookup(pk, &context.pool)
            .await
            .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(row.map(|row| row.try_into().ok()).flatten())
    }

    async fn list_crafting_facility(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::accounts::graphql::CraftingFacilityGraphQL>> {
        let rows: Vec<crate::accounts::postgres::CraftingFacilityRow> = sqlx::query_as(
            r#"SELECT * FROM crafting_facility_account ORDER BY __slot DESC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn crafting_process(
        context: &crate::graphql::context::GraphQLContext,
        pubkey: String,
    ) -> FieldResult<Option<crate::accounts::graphql::CraftingProcessGraphQL>> {
        use carbon_core::postgres::operations::LookUp;
        use carbon_core::postgres::primitives::Pubkey as PgPubkey;
        let pk = PgPubkey(
            solana_pubkey::Pubkey::from_str(&pubkey)
                .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?,
        );
        let row = crate::accounts::postgres::CraftingProcessRow::lookup(pk, &context.pool)
            .await
            .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(row.map(|row| row.try_into().ok()).flatten())
    }

    async fn list_crafting_process(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::accounts::graphql::CraftingProcessGraphQL>> {
        let rows: Vec<crate::accounts::postgres::CraftingProcessRow> = sqlx::query_as(
            r#"SELECT * FROM crafting_process_account ORDER BY __slot DESC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn domain(
        context: &crate::graphql::context::GraphQLContext,
        pubkey: String,
    ) -> FieldResult<Option<crate::accounts::graphql::DomainGraphQL>> {
        use carbon_core::postgres::operations::LookUp;
        use carbon_core::postgres::primitives::Pubkey as PgPubkey;
        let pk = PgPubkey(
            solana_pubkey::Pubkey::from_str(&pubkey)
                .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?,
        );
        let row = crate::accounts::postgres::DomainRow::lookup(pk, &context.pool)
            .await
            .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(row.map(|row| row.try_into().ok()).flatten())
    }

    async fn list_domain(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::accounts::graphql::DomainGraphQL>> {
        let rows: Vec<crate::accounts::postgres::DomainRow> = sqlx::query_as(
            r#"SELECT * FROM domain_account ORDER BY __slot DESC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn recipe(
        context: &crate::graphql::context::GraphQLContext,
        pubkey: String,
    ) -> FieldResult<Option<crate::accounts::graphql::RecipeGraphQL>> {
        use carbon_core::postgres::operations::LookUp;
        use carbon_core::postgres::primitives::Pubkey as PgPubkey;
        let pk = PgPubkey(
            solana_pubkey::Pubkey::from_str(&pubkey)
                .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?,
        );
        let row = crate::accounts::postgres::RecipeRow::lookup(pk, &context.pool)
            .await
            .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(row.map(|row| row.try_into().ok()).flatten())
    }

    async fn list_recipe(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::accounts::graphql::RecipeGraphQL>> {
        let rows: Vec<crate::accounts::postgres::RecipeRow> = sqlx::query_as(
            r#"SELECT * FROM recipe_account ORDER BY __slot DESC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn recipe_category(
        context: &crate::graphql::context::GraphQLContext,
        pubkey: String,
    ) -> FieldResult<Option<crate::accounts::graphql::RecipeCategoryGraphQL>> {
        use carbon_core::postgres::operations::LookUp;
        use carbon_core::postgres::primitives::Pubkey as PgPubkey;
        let pk = PgPubkey(
            solana_pubkey::Pubkey::from_str(&pubkey)
                .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?,
        );
        let row = crate::accounts::postgres::RecipeCategoryRow::lookup(pk, &context.pool)
            .await
            .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(row.map(|row| row.try_into().ok()).flatten())
    }

    async fn list_recipe_category(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::accounts::graphql::RecipeCategoryGraphQL>> {
        let rows: Vec<crate::accounts::postgres::RecipeCategoryRow> = sqlx::query_as(
            r#"SELECT * FROM recipe_category_account ORDER BY __slot DESC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    // Instructions (per-instruction list and lookup by signature+index)
    async fn add_consumable_input_to_recipe(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::AddConsumableInputToRecipeGraphQL>> {
        let rows: Vec<crate::instructions::postgres::AddConsumableInputToRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM add_consumable_input_to_recipe_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_add_consumable_input_to_recipe(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::AddConsumableInputToRecipeGraphQL>> {
        let rows: Vec<crate::instructions::postgres::AddConsumableInputToRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM add_consumable_input_to_recipe_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn add_crafting_facility_recipe_category(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::AddCraftingFacilityRecipeCategoryGraphQL>>
    {
        let rows: Vec<crate::instructions::postgres::AddCraftingFacilityRecipeCategoryRow> = sqlx::query_as(
            r#"SELECT * FROM add_crafting_facility_recipe_category_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_add_crafting_facility_recipe_category(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::AddCraftingFacilityRecipeCategoryGraphQL>>
    {
        let rows: Vec<crate::instructions::postgres::AddCraftingFacilityRecipeCategoryRow> = sqlx::query_as(
            r#"SELECT * FROM add_crafting_facility_recipe_category_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn add_non_consumable_input_to_recipe(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::AddNonConsumableInputToRecipeGraphQL>> {
        let rows: Vec<crate::instructions::postgres::AddNonConsumableInputToRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM add_non_consumable_input_to_recipe_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_add_non_consumable_input_to_recipe(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::AddNonConsumableInputToRecipeGraphQL>> {
        let rows: Vec<crate::instructions::postgres::AddNonConsumableInputToRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM add_non_consumable_input_to_recipe_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn add_output_to_recipe(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::AddOutputToRecipeGraphQL>> {
        let rows: Vec<crate::instructions::postgres::AddOutputToRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM add_output_to_recipe_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_add_output_to_recipe(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::AddOutputToRecipeGraphQL>> {
        let rows: Vec<crate::instructions::postgres::AddOutputToRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM add_output_to_recipe_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn add_recipe_ingredient(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::AddRecipeIngredientGraphQL>> {
        let rows: Vec<crate::instructions::postgres::AddRecipeIngredientRow> = sqlx::query_as(
            r#"SELECT * FROM add_recipe_ingredient_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_add_recipe_ingredient(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::AddRecipeIngredientGraphQL>> {
        let rows: Vec<crate::instructions::postgres::AddRecipeIngredientRow> = sqlx::query_as(
            r#"SELECT * FROM add_recipe_ingredient_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn burn_consumable_ingredient(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::BurnConsumableIngredientGraphQL>> {
        let rows: Vec<crate::instructions::postgres::BurnConsumableIngredientRow> = sqlx::query_as(
            r#"SELECT * FROM burn_consumable_ingredient_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_burn_consumable_ingredient(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::BurnConsumableIngredientGraphQL>> {
        let rows: Vec<crate::instructions::postgres::BurnConsumableIngredientRow> = sqlx::query_as(
            r#"SELECT * FROM burn_consumable_ingredient_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn claim_non_consumable_ingredient(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::ClaimNonConsumableIngredientGraphQL>> {
        let rows: Vec<crate::instructions::postgres::ClaimNonConsumableIngredientRow> = sqlx::query_as(
            r#"SELECT * FROM claim_non_consumable_ingredient_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_claim_non_consumable_ingredient(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::ClaimNonConsumableIngredientGraphQL>> {
        let rows: Vec<crate::instructions::postgres::ClaimNonConsumableIngredientRow> = sqlx::query_as(
            r#"SELECT * FROM claim_non_consumable_ingredient_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn claim_recipe_output(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::ClaimRecipeOutputGraphQL>> {
        let rows: Vec<crate::instructions::postgres::ClaimRecipeOutputRow> = sqlx::query_as(
            r#"SELECT * FROM claim_recipe_output_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_claim_recipe_output(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::ClaimRecipeOutputGraphQL>> {
        let rows: Vec<crate::instructions::postgres::ClaimRecipeOutputRow> = sqlx::query_as(
            r#"SELECT * FROM claim_recipe_output_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn create_crafting_process(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::CreateCraftingProcessGraphQL>> {
        let rows: Vec<crate::instructions::postgres::CreateCraftingProcessRow> = sqlx::query_as(
            r#"SELECT * FROM create_crafting_process_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_create_crafting_process(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::CreateCraftingProcessGraphQL>> {
        let rows: Vec<crate::instructions::postgres::CreateCraftingProcessRow> = sqlx::query_as(
            r#"SELECT * FROM create_crafting_process_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn deregister_crafting_facility(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::DeregisterCraftingFacilityGraphQL>> {
        let rows: Vec<crate::instructions::postgres::DeregisterCraftingFacilityRow> = sqlx::query_as(
            r#"SELECT * FROM deregister_crafting_facility_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_deregister_crafting_facility(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::DeregisterCraftingFacilityGraphQL>> {
        let rows: Vec<crate::instructions::postgres::DeregisterCraftingFacilityRow> = sqlx::query_as(
            r#"SELECT * FROM deregister_crafting_facility_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn deregister_recipe_category(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::DeregisterRecipeCategoryGraphQL>> {
        let rows: Vec<crate::instructions::postgres::DeregisterRecipeCategoryRow> = sqlx::query_as(
            r#"SELECT * FROM deregister_recipe_category_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_deregister_recipe_category(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::DeregisterRecipeCategoryGraphQL>> {
        let rows: Vec<crate::instructions::postgres::DeregisterRecipeCategoryRow> = sqlx::query_as(
            r#"SELECT * FROM deregister_recipe_category_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn drain_craftable_item_bank(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::DrainCraftableItemBankGraphQL>> {
        let rows: Vec<crate::instructions::postgres::DrainCraftableItemBankRow> = sqlx::query_as(
            r#"SELECT * FROM drain_craftable_item_bank_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_drain_craftable_item_bank(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::DrainCraftableItemBankGraphQL>> {
        let rows: Vec<crate::instructions::postgres::DrainCraftableItemBankRow> = sqlx::query_as(
            r#"SELECT * FROM drain_craftable_item_bank_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn initialize_domain(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::InitializeDomainGraphQL>> {
        let rows: Vec<crate::instructions::postgres::InitializeDomainRow> = sqlx::query_as(
            r#"SELECT * FROM initialize_domain_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_initialize_domain(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::InitializeDomainGraphQL>> {
        let rows: Vec<crate::instructions::postgres::InitializeDomainRow> = sqlx::query_as(
            r#"SELECT * FROM initialize_domain_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn legitimize_recipe_ingredient(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::LegitimizeRecipeIngredientGraphQL>> {
        let rows: Vec<crate::instructions::postgres::LegitimizeRecipeIngredientRow> = sqlx::query_as(
            r#"SELECT * FROM legitimize_recipe_ingredient_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_legitimize_recipe_ingredient(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::LegitimizeRecipeIngredientGraphQL>> {
        let rows: Vec<crate::instructions::postgres::LegitimizeRecipeIngredientRow> = sqlx::query_as(
            r#"SELECT * FROM legitimize_recipe_ingredient_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn register_craftable_item(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RegisterCraftableItemGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RegisterCraftableItemRow> = sqlx::query_as(
            r#"SELECT * FROM register_craftable_item_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_register_craftable_item(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RegisterCraftableItemGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RegisterCraftableItemRow> = sqlx::query_as(
            r#"SELECT * FROM register_craftable_item_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn register_crafting_facility(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RegisterCraftingFacilityGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RegisterCraftingFacilityRow> = sqlx::query_as(
            r#"SELECT * FROM register_crafting_facility_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_register_crafting_facility(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RegisterCraftingFacilityGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RegisterCraftingFacilityRow> = sqlx::query_as(
            r#"SELECT * FROM register_crafting_facility_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn register_recipe(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RegisterRecipeGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RegisterRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM register_recipe_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_register_recipe(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RegisterRecipeGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RegisterRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM register_recipe_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn register_recipe_category(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RegisterRecipeCategoryGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RegisterRecipeCategoryRow> = sqlx::query_as(
            r#"SELECT * FROM register_recipe_category_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_register_recipe_category(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RegisterRecipeCategoryGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RegisterRecipeCategoryRow> = sqlx::query_as(
            r#"SELECT * FROM register_recipe_category_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn remove_consumable_input_from_recipe(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RemoveConsumableInputFromRecipeGraphQL>>
    {
        let rows: Vec<crate::instructions::postgres::RemoveConsumableInputFromRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM remove_consumable_input_from_recipe_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_remove_consumable_input_from_recipe(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RemoveConsumableInputFromRecipeGraphQL>>
    {
        let rows: Vec<crate::instructions::postgres::RemoveConsumableInputFromRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM remove_consumable_input_from_recipe_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn remove_crafting_facility_recipe_category(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RemoveCraftingFacilityRecipeCategoryGraphQL>>
    {
        let rows: Vec<crate::instructions::postgres::RemoveCraftingFacilityRecipeCategoryRow> = sqlx::query_as(
            r#"SELECT * FROM remove_crafting_facility_recipe_category_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_remove_crafting_facility_recipe_category(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RemoveCraftingFacilityRecipeCategoryGraphQL>>
    {
        let rows: Vec<crate::instructions::postgres::RemoveCraftingFacilityRecipeCategoryRow> = sqlx::query_as(
            r#"SELECT * FROM remove_crafting_facility_recipe_category_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn remove_non_consumable_input_from_recipe(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RemoveNonConsumableInputFromRecipeGraphQL>>
    {
        let rows: Vec<crate::instructions::postgres::RemoveNonConsumableInputFromRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM remove_non_consumable_input_from_recipe_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_remove_non_consumable_input_from_recipe(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RemoveNonConsumableInputFromRecipeGraphQL>>
    {
        let rows: Vec<crate::instructions::postgres::RemoveNonConsumableInputFromRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM remove_non_consumable_input_from_recipe_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn remove_output_from_recipe(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RemoveOutputFromRecipeGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RemoveOutputFromRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM remove_output_from_recipe_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_remove_output_from_recipe(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RemoveOutputFromRecipeGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RemoveOutputFromRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM remove_output_from_recipe_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn remove_recipe_ingredient(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RemoveRecipeIngredientGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RemoveRecipeIngredientRow> = sqlx::query_as(
            r#"SELECT * FROM remove_recipe_ingredient_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_remove_recipe_ingredient(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::RemoveRecipeIngredientGraphQL>> {
        let rows: Vec<crate::instructions::postgres::RemoveRecipeIngredientRow> = sqlx::query_as(
            r#"SELECT * FROM remove_recipe_ingredient_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn start_crafting_process(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::StartCraftingProcessGraphQL>> {
        let rows: Vec<crate::instructions::postgres::StartCraftingProcessRow> = sqlx::query_as(
            r#"SELECT * FROM start_crafting_process_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_start_crafting_process(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::StartCraftingProcessGraphQL>> {
        let rows: Vec<crate::instructions::postgres::StartCraftingProcessRow> = sqlx::query_as(
            r#"SELECT * FROM start_crafting_process_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn stop_crafting_process(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::StopCraftingProcessGraphQL>> {
        let rows: Vec<crate::instructions::postgres::StopCraftingProcessRow> = sqlx::query_as(
            r#"SELECT * FROM stop_crafting_process_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_stop_crafting_process(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::StopCraftingProcessGraphQL>> {
        let rows: Vec<crate::instructions::postgres::StopCraftingProcessRow> = sqlx::query_as(
            r#"SELECT * FROM stop_crafting_process_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn update_crafting_facility(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::UpdateCraftingFacilityGraphQL>> {
        let rows: Vec<crate::instructions::postgres::UpdateCraftingFacilityRow> = sqlx::query_as(
            r#"SELECT * FROM update_crafting_facility_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_update_crafting_facility(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::UpdateCraftingFacilityGraphQL>> {
        let rows: Vec<crate::instructions::postgres::UpdateCraftingFacilityRow> = sqlx::query_as(
            r#"SELECT * FROM update_crafting_facility_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn update_domain(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::UpdateDomainGraphQL>> {
        let rows: Vec<crate::instructions::postgres::UpdateDomainRow> = sqlx::query_as(
            r#"SELECT * FROM update_domain_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_update_domain(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::UpdateDomainGraphQL>> {
        let rows: Vec<crate::instructions::postgres::UpdateDomainRow> = sqlx::query_as(
            r#"SELECT * FROM update_domain_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn update_recipe(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::UpdateRecipeGraphQL>> {
        let rows: Vec<crate::instructions::postgres::UpdateRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM update_recipe_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_update_recipe(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::UpdateRecipeGraphQL>> {
        let rows: Vec<crate::instructions::postgres::UpdateRecipeRow> = sqlx::query_as(
            r#"SELECT * FROM update_recipe_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn update_recipe_category(
        context: &crate::graphql::context::GraphQLContext,
        signature: String,
        instruction_index: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::UpdateRecipeCategoryGraphQL>> {
        let rows: Vec<crate::instructions::postgres::UpdateRecipeCategoryRow> = sqlx::query_as(
            r#"SELECT * FROM update_recipe_category_instruction WHERE __signature = $1 AND __instruction_index = $2 ORDER BY __stack_height ASC"#,
        )
        .bind(signature)
        .bind(instruction_index)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }

    async fn list_update_recipe_category(
        context: &crate::graphql::context::GraphQLContext,
        limit: i32,
        offset: i32,
    ) -> FieldResult<Vec<crate::instructions::graphql::UpdateRecipeCategoryGraphQL>> {
        let rows: Vec<crate::instructions::postgres::UpdateRecipeCategoryRow> = sqlx::query_as(
            r#"SELECT * FROM update_recipe_category_instruction ORDER BY __slot DESC, __signature DESC, __instruction_index ASC LIMIT $1 OFFSET $2"#,
        )
        .bind(limit)
        .bind(offset)
        .fetch_all(&*context.pool)
        .await
        .map_err(|e| juniper::FieldError::new(e.to_string(), juniper::Value::null()))?;
        Ok(rows
            .into_iter()
            .filter_map(|row| row.try_into().ok())
            .collect())
    }
}
